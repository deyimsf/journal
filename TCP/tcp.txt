Tcp首部数据格式
 0                                15  16                                31
 -------------------------------------------------------------------------
 |		16位源端口号         |		16位目的端口号           |
 -------------------------------------------------------------------------
 |				32位序号				 |
 -------------------------------------------------------------------------
 |				32位确认序号				 |
 -------------------------------------------------------------------------
 |            |          |U|A|P|R|S|F|					 |
 |4位首部长度 | 保留(6位)|R|C|S|S|Y|I|		16位窗口大小		 |
 |	      |		 |G|K|H|T|N|N|					 |
 -------------------------------------------------------------------------
 |              16位校验和           |       16位紧急指针                |
 -------------------------------------------------------------------------
 |                               自定义选项                              |
 -------------------------------------------------------------------------
 |                                 数据                                  |
 -------------------------------------------------------------------------

Tcp首部中6个标志比特说明
 URG	紧急指针(urgent pointer)
 ACK	确认应答
 PSH	接收方应该尽快将这个报文段交给应用层
 RST	重建连接
 SYN	请求建立连接
 FIN	请求断开连接

Tcp建立连接  mss:Maximum Segement Size  MTU:Maxmum Transmission Unit(链路层叫法)
            SYN 157445:157445 <mss 1024>
 --------------------------------------------------->
      SYN 189893:189893 ack 157446 , <mss 1024>
 <---------------------------------------------------
                    ack 189894
 --------------------------------------------------->

Tcp终止连接
           FIN
  ---------------------->
           ACK
  <---------------------
           FIN
  <---------------------
           ACK
  --------------------->

套接字复位(RST,异常关闭)
 RST报文段不会导致另一端产生任何响应，另一端根本不进行确认。
 收到RST的一方将终止该连接，并通知应用层连接复位。
 java例子:
  ServerSocket ss = new ServerSocket(8989);
  whil(true){
	Socket s = ss.accept();
	s.setSoLinger(true,0);
	s.close();
 } 

半打开连接
 如果一方已经关闭或异常终止连接而另一方还不知道，这种TCP连接称为半打开(Half-Open)
 只要不打算在半打开连接上传输数据，仍处于连接状态的一方就不会检测另一方已经出现异常。

半关闭
  TCP连接的一端在结束它的发送后还能接收来自另一端数据的能力。很少应用程序使用。

SO_REUSEADDR
 该选项可以决定，处在TIME_WAIT状态的连接是否可以被新的连接使用
SO_LINGER
 设置停留时间，如果停留时间设置为0，连接关闭是会用复位(RST)而不
 是用正常的FIN。这样会避免主动关闭端出现TIME_WAIT状态。
TCP_NODELAY
 *可以用来关闭Nagle算法；
 *Nagle算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，
  在该分组的确认未到达之前不能发送其他的小分组。同时在等待确认应答
  道来时，Tcp会收集这些小分组，然后打包发送。
 *如果服务端从不向客户端发送数据，那么就会经常触发服务器的经受时延的
  确认算法，会有一个200ms内的确认延迟。
SO_RCVBUF
 设置窗口大小

TCP滴答计时器(比如200ms一个滴答)   
  TCP软件启动，每隔200ms一个滴答，如下图
    0___1___2___3___4___5___6___7___8___9___10___11___12...504...
  
   设置一个1秒的定时器，需要为该定时器的计数器设为5个滴答
     如果刚好在2这个滴答时候之后设置定时器成功，那么该定时器经历3、4、5、6、7这5个
   滴答之后计数器恢复为零。该定时器历经1秒。
     如果在2~3这两个滴答中间设置计数器，那么该定时器同样经历3、4、5、6、7这5个滴答。
   此时定时器经历900ms。
   
TCP往返时间(RTT)的测定
   在一个连接中，每次发送数据都会先检查定时器是否被使用，如果没有则定时器启动并开始计时，
 待这次发送的数据返回ack后，定时器关闭并记录经历的滴答个数。
    

Tcp慢启动和避免拥塞算法
  该算法可以看"慢启动和避免拥塞算法.jpg/.docx"
  常规避免拥塞算法在发送超时拥塞时，会设置成慢启动(cwnd=1),这时候效率就比较低。
  "快速重传与快速恢复算法"，可以有效避免启用慢启动算法，而是直接用避免拥塞算法。

滑动窗口
 *窗口左边沿向右边沿靠近称为窗口合拢。发生在数据被发送和确认时。
 *窗口右边沿向右边移动时将允许发送更多的数据，叫窗口张开。发生在另一端接收进程读取
  已确认的数据并释放了TCP缓存时。
 *右边向左边移动时，叫窗口收缩。Host Requirements RFC不建议使用这种方式。
 
