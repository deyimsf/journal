##############################GenericObjectPool.java#####################
	/**
	 * The cap on the number of idle instances in the pool.
     * 池中最大空闲实例个数
     * (向pool中添加实例或者将实例放回pool中时会用到)
     */
    private int _maxIdle = DEFAULT_MAX_IDLE;

    /**
    * The cap on the minimum number of idle instances in the pool.
    * 池中最小空闲实例个数
    */
    private int _minIdle = DEFAULT_MIN_IDLE;

    /**
     * The cap on the total number of active instances from the pool. 
     * 最多活跃的实例个数
     */
    private int _maxActive = DEFAULT_MAX_ACTIVE;

    /**
     * 当池耗尽并且whenExhaustedAction的值是WHEN_EXHAUSTED_BLOCK时候,
     * borrowObject方法最大等待时间(毫秒),超过改时间则抛出异常
     * 当小于等于0时，一直阻塞
     */
    private long _maxWait = DEFAULT_MAX_WAIT;

    /** 
     * 当池被耗尽时，borrowObject方法应该采取的措施
     */
    private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;

    /** 
     * 默认是false，当是true得时候，borrowObject方法在返回之前
     * 会调用自定义的PoolableObjectFactory.validateObject方法，校验
     * 要返回的对象是否可用.如果不可用，该对象会被销毁，然后
     * 会尝试生成另一个对象.
     */
    private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;

    /**
     * 默认是false，当时true的时候，当调用retruenObject将对象放回
     * 池中时会调用PoolableObjectFactory.validateObject方法，校验对象
     * 是否可用.
     * (如果不可用会销毁该对象)
     */
    private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;

    /**
     * 默认是fasle，当是true时，闲置对象驱逐器会调用validateObject
     * 方法，校验对象是否可用，如果不可用会将其从池中drop掉
     */
    private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;

    /**
     * 闲置对象驱逐器运行的间隔时间(毫秒)，如果是非正数
     * 则驱逐器将不会运行.
     * (驱逐器可以确保池内对象不小于minIdle并且不大于maxIdle)
     */
    private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;

    /**
     * 驱逐器每次运行时检查池中闲置对象的最大个数
     * (比如该值设置为3,此时池中有5个闲置对象,那么每次
     * 只会检查前三个闲置对象。比如检查闲置对象是否可用等。
     * 确保minIdle不受这个影响，因为是做完检查后才执行确保代码)
     * 
     * When a negative value is supplied, <tt>ceil({@link #getNumIdle})/
	 * abs({@link #getNumTestsPerEvictionRun})</tt> tests will be run.
	 * I.e., when the value is <i>-n</i>, roughly one <i>n</i>th of the
     * idle objects will be tested per run.
     */
    private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;

    /**
     * 一个对象可以停留在池中的最少闲置时间，如果该对象在池中
     * 的闲置时间大于该值，那么该对象就可以被驱逐器dorp掉。
     * 
     * 如果是非正数，表示该对象可以一直闲置下去。
     */
    private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;

    /**
     * 和minEvictableIdleTimeMillis作用一样，但有一个额外条件：
     * 如果池中闲置对象的个数不大于minIdle时，即使有对象的
     * 闲置时间大于该设置的值也不会被dorp掉.
     * 
     * 注意：如果minEvictableIdleTimeMillis>0则该参数就不在起作用.
     */
    private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;

    /** 
	 * 默认LIFO状态.True的意思是borrowObject方法返回池中的最近 
     * 使用过的闲置对象(如果该实例可用). Fasle的意思是池是一个 FIFO队列
	 */
    private boolean _lifo = DEFAULT_LIFO;

    /** My pool. */
    private CursorableLinkedList<ObjectTimestampPair<T>> _pool = null;

    /** Eviction cursor - keeps track of idle object evictor position */
    private CursorableLinkedList<ObjectTimestampPair<T>>.Cursor _evictionCursor = null;

    /** My {@link PoolableObjectFactory}. */
    private PoolableObjectFactory<T> _factory = null;

    /**
     * The number of objects {@link #borrowObject} borrowed
     * from the pool, but not yet returned.
     */
    private int _numActive = 0;

    /**
     * My idle object eviction {@link TimerTask}, if any.
     */
    private Evictor _evictor = null;

    /**
     * The number of objects subject to some form of internal processing
     * (usually creation or destruction) that should be included in the total
     * number of objects but are neither active nor idle.
     *  
     * 没看懂
     */
    private int _numInternalProcessing = 0;

    /**
     * Used to track the order in which threads call {@link #borrowObject()} so
     * that objects can be allocated in the order in which the threads requested
     * them.
     */
    private final LinkedList<Latch<T>> _allocationQueue = new LinkedList<Latch<T>>();

