#运算符及其优先级
 --------------------------------------------------------------
  顺序       运算符             说明
 --------------------------------------------------------------
   1           ()
               []
               .               按对象选择成员
               ->              按指针选择成员
   2           + -             一元加和一元减,如-89
               ++ --           前缀递增和前缀递减
               ! ~             逻辑非和按位补
               *               取消引用(也称为间接运算符)
               &               寻址
               sizeof
               (type)          强制转换为type,如(int)
   3           * / %
   4           + -
   5           <<  >>
   6           < <= > >=
   7           == !=
   8           &               按位与
   9           ^               按位异或
   10          |               
   11          &&              逻辑与
   12          ||
   13          ?:              条件运算符
   14          = += -= /= *=
               %= <<= >>= &=
               |= ^=
   15          ,               逗号运算符
 ---------------------------------------------------------------               

#三字母转义序列
  ??=  #
  ??/  \
  ??'  ^
  ??(  [
  ??<  {
  ??!  |
  ??)  ]
  ??>  }
  ??-  ~	

#极限值
 <limits.h>: 定义了数据类型的极限值
  类型			下限	    	上限
  int 		   INT_MIN	  	  INT_MAX
  long		   LONG_MIN		  LONG_MAX	

 <float.h>: 定义了浮点数的极限值
  float		   FLT_MIN		  FLT_MAX
  double 	   DBL_MIN		  DBL_MAX

#C语言的几种基本数据类型
 char 字符型，一个字节
 int 整形，通常反映所用机器中整数的最自然长度，至少16位
 float 当精度浮点
 double 双精度浮点
 
#限定符
 short
 long
 signed
 unsigned

#各个数据类型占用的字节数 
  ---------------------------------------------------------------
    类型名称							字节数		  后缀
  ---------------------------------------------------------------
   char		 							  1             /
   short  int							  2             /
   int									  2/4           /
   long int							      4				L
   long long int						  8				LL

   unsigned char						  1				/
   unsigned short int 					  2				/
   unsigned int							  2/4			U
   unsigned long int					  4				UL
   unsigned long long int				  8				ULL

   float								  4
   double								  8
   long double							  12

   unsigned float						  4
   unsigned double						  8
   unsigned long double					  12
  --------------------------------------------------------------

#字符转大小写
 <ctype.h>   标准库
 toupper()
 tolower() 

#枚举(是一个整数类型)
 定义一个枚举,默认每个枚举常量的值是从0开始,依次加1的整形。每个枚举常量的名称是
 唯一的,但常量的值可以相同:
 	enum Weekday {Monday,Tuesday,Wednesday,Thursday,Firday,Saturday,Sunday};
    该定义的枚举常量值为0~6  

	enum color {red=1,orage,yellow=1,green}
    常量值分别为(1,2,1,2)

 定义完后就可以用指定的枚举常量为枚举赋值了
 声明一个枚举变量并赋值
  enum Weekday var = Tuesday;
  enum Weekday var = 1;

 注意:可以给枚举类型指定一组可能的值,但没有检查机制来确保程序只使用这些值.
      所以对于 enum Weekday var = 123;也是可行的。

#C11标准的可选函数的使用
 实现C11标准可选函数的编译器都会定义__STDC_LIB_EXT1__符号,所以可以根据
 该符号来判断是否支持可选函数:
	int main(){
		#if defined __STDC_LIB_EXT1__
			printf("支持");
		#else
			printf("不支持");
		#endif
	}
 
 如果支持且要使用string.h中的可选函数,必须在string.h前定义__STDC_WANT_LIB_EXT1__符号
 为1才能真正的使用:
	#define __STDC_WANT_LIB_EXT1__  1
	#include <string.h>

 注意:C11的可选函数都以_s结尾

#const用该关键字修饰的变量是只读的(但不是常量)
 const int a = 3; //对该变量修改会报错
 const char str[] = "hello";
	str[0] = 'a'; //错误,变量的内容是只读的
 const char *str = "hello";
	str = "abc"; //正确,没有修改变量的内容
 	
 
'\000' 用八进制表示一个字符 如'\013'
'\xhh' 用十六进制表示一个字符 如'\xb'

#按位运算符
 &  按位与
 |  按位或
 ^  按位异或
 << 左移
 >> 右移 ,逻辑右移(高位补零)或算数右移(高位补符号位)取决于编译系统
 ~  按位求反

#if语句
 if (){ 
   ...
 }else if(){
   ...
 }else{
   ...
 }

#switch语句
 switch(num){
	case 35:
		...
		break;
	default:
		...
		break;
 }


#C语言没有指定同一运算符的计算顺序
 例如x = f() + g(); 两个函数的计算顺序依赖于具体的编译器
#C语言也没有指定函数参数的求职顺序
 printf("%d %d\n",++n,power(2,n)); 不确定++n先执行还是pwoer()先执行
a[i] = i++; 存在同样的问题

#函数声明又称函数原型
 就像普通变量一样,函数在使用之前也需要先声明;
 函数声明的时候只需要使用函数的签名并在尾部加上分号,如:
	int abc(int a,int b); //一个函数声明
 函数声明的时候,参数名不需要和函数定义的参数名相同,甚至不需要在函数声明中
 包含参数名,如:
	int abc(int,int);  //不包含参数名的函数声明,但是参数的个数和类型要和定义的一直
 
 函数原型的作用域是,从其声明处开始一直到源文件的结尾。

#extern修饰函数
 用extern修饰的函数是表示被修饰的函数定义在当前文件外,并且当前文件及其include
 的头文件都没有该函数的声明.
 例如:
	//--------文件hello.c-----------------
	  #include <stdio.h>
	  
	  void hello(void){
		printf("hello\n");
	  }
    //-------------------------------------

    //---------文件main.c-------------------
      //声明这是一个外部函数,编译的时候不会检查是否存在
   	  //只有在连接的时候才会用到它
      extern void hello(void);

      int main(void){
	  	hello();
		return 0;
	  }
    //--------------------------------------
 我们编译并连接这两个c文件
 	$gcc -o main hello.c main.c
 执行它:
	$sh main //执行
    $hello   //输出hello

 注意:如果hello()函数是static修饰的,则表示只有在定义它的源文件中
  才能使用和函数声明,在其他文件中是不能声明也不能用extern修饰的。
  


#函数隐式声明
 如果函数没有原型声明，那么函数会在第一次出现的地方被隐式声明。
 被声明的函数返回值被假定为int型，但不对参数做类型假设。

#函数的声明和定义必须一致，如果声明和定义在一个文件，则编译器会检查到是否一致。
 如果不在同一个文件，则无法检测到，这件会导致声明是int，定义且是其他类型(如double).
 所以函数的声明和定义最好在一个文件中。

#函数声明的一个例子
   int sum;
   //cc 这函数第一次出现，所以隐式声明为 int cc();
   //不对参数做假设.所以输入什么参数都可以.
   //注意：int cc(); int cc(void); 这两种声明是不一样的，
   //int cc()会把后边出现的第一个int cc(...){}视为定义
   //int cc(void) 只会把 int cc(){} 视为定义
   sum = cc("2.4");

   1) int cc(char a[]){}
   //如果1) 随后首先出现，那么1) 将被视为函数定义

   2) int cc(char a[], char b[]){}
   //如果2) 随后首先出现，那么2) 将被视为函数定义
 
   注意：1)和2)不可同时出现，因为名字相同，所以视为重复定义

   3) double cc(char a[] , char b[]){} 
   //如果3) 随后首先出现,那么3) 被视为重复声明, 并不会把这个函数看成一个定义。
   //因为前面隐式声明的类型是int,而这里是一个double
   //类似这样：int cc(); double cc();

   注意：函数声明时按照名字来确定是否已经声明；按照声明的类型和名字
         确定是否定义了函数。C语言中不会存在同名的函数。

#声明指针变量和普通变量
 int a,*b,c;
 其中a,c为普通变量。b是指针变量。

#指针和指针变量
 int* x:  //int型指针
 void* y 
   任意类型指针,实际用的时候可以强转成具体的类型指针。void*类似于java中的Object
 
 //为指针分配空间并使用
 x = malloc(sizeof(int));
 *x = 5;

 y = malloc(sizeof(int));
 *y = 5; //错误,void*类型的指针使用时需要转换成具体类型
 x = (int*)y;
 x = 5;  //正确

 #include <stdio.h>
 main(){
	int  x=2;
	int* y = &x; //y是一个整型指针(地址)变量,&x是一个整型指针(地址) *y是y这个地址所指向的内容，是个整型.

	printf("%d\n",y);     //表示地址
	printf("%d\n",&x);    //表示地址
	printf("%d\n",&(*y)); //表示*y这个整型的地址

	printf("%d\n",*y);    //内存地址指向的内容
	printf("%d\n",*(&x)); //内存地址指向的内容
 }

#指向常量的指针
 不能通过指针的方式,去改变'指针指向'的值;
 例子1: 
	int value = 999;
 	const int *pv = &value;  
 这是一个指向常量的指针,也就是说不能通过pv来改变pv指向的值
	*pv = 888;   //这是错误的
 但是可以通过value进行任意更改
	value = 777; //这个是可以的,因为没有通过指针去改变这个值

 例子2:
	int num = 888;
	pv = &num;   //pv指向的地址可以改变
 指针变量的地址可以改变,但是仍然不能使用指针来改变它指向的值
	*pv = 666;  //仍然是错误的
	num = 555;  //Ok

#常量指针
 指针中存储的地址不能改变,指向的值可以改变
 例子:
	int count = 56;
	int *const pv = $count;   //定义个常量指针并赋值
 如果试图改修改指针存储的地址,则会报错
	pv = &count;  //编译错误,pv是一个只读的变量

#指向常量的常量指针
 就是将上面两个概念结合起来:
	指针地址不可修改;
	不能通过指针的方式去改变它指向的值;
 例如:
	int value = 30;
	const int *const pv = &value;  //指向常量的(const int) 常量指针(*const pv)
 	
	pv = &value;  //编译错误,该指针不可修改(常量指针)
    *pv = 89;     //编译错误,不能用指针的方式修改其指向的值
 
	value = 20;   //合法,因为value是可修改的

#用stdlib.h/malloc()函数分配内存
 分配可以容纳25个int型的内存
	 int *pv = (int *)malloc(25*sizeof(int));
	 if(pv == NULL){
		printf("分配内存失败");	
	 }
#stdlib.h/free()释放内存
 释放的地址必须是分配时的地址,否则结果是不确定的,假设pv是分配是的地址
	free(pv);
	pv = NULL; 

#stdlib.h/calloc()分配内存
 该函数分配的内存会把所有的位初始化为0,例如分配25个int大小的内存
	int *pv = (int *)calloc(25,sizeof(int));
	if(pv == NULL){
		printf("内存分配失败");
	}

#stdlib.h/realloc()重新分配内存
 该函数可以扩展以前用malloc()、calloc()、realloc()分配的内存.
 两个参数:
	一个是以前有上面三个函数返回的指针地址;
	另一个是要分配的新内存的字节数,该值可以大于之前的值,也可以小于之前的值.
	当扩大一块内存空间时,realloc()视图直接从原空间后面获取连续的附加字节,如果
    可以满足则直接扩大空间,否则就需要重新分配一块新的内存,并把原数据考过来.
 例子:
	#include <stdio.h>
    #include <stdlib.h>
  
    int main(){
       int *pv = (int *)realloc(NULL,5*sizeof(int));
       printf("%p\n",pv); //新分配的内存
   
       int *npv = (int *)realloc(pv,10*sizeof(int));
       printf("%p\n",npv);//如果pv后面有连续的5个int型大小的字节,则npv等于pv
 
       int *nnpv = (int *)realloc(npv,8*sizeof(int));
       printf("%p\n",nnpv);//缩小内存,所以nnpv等npv
    }
    
 realloc()失败时返回NULL,并且原来的内存不变,不释放也不移动
 	
 如果第一个参数是NULL,那么它就等同于malloc()函数:
	int *npv = (int *)realloc(NULL,50*sizeof(int));
 如果第一个参数不是NULL,也不是之前分配的地址,或者指向已释放的内存,
 则结果是不确定的。



#C中变量作用域	
 连接器如何解析多重定义的全局符号
    强符号：函数和以初始化的全局变量
    弱符号：未初始化的全局变量 
    1.不允许有多个相同的强符号
    2.如果有一个强符号和多个弱符号，那么选择强符号
    3.如果有多个相同弱符号，那么从这个弱符号中任意选择一个
		
 在函数外的是全局变量，相同的强符号的全局变量名在整个程序中只能出现一次，
 不管这个程序是在一个文件中，还是分散在多个文件中的。
 
 在函数内的是局部变量，函数内的和函数外的相同名字的变量不会冲突。
 如果函数内要访问外部变量，如果在同一个文件内，且函数的位置在外部
 变量的后面，则可以访问，否则需要用extern进行声明。

 static修饰符可以将变量的访问范围锁定在文件内或函数内，并且该变量
 一直占用空间。
 如果变量 static int sp = 0;在某个文件内,则其他任何文件都无法访问
 该变量;如果在函数内,和其他变量的区别是,函数结束后该变量不释放空间

#宏定义
 #define 名字 替换文本
 宏定义只是做简单的文本替换：
  #define max(A,B) A * B
  使用宏max看起来很像是函数调用,但宏调用直接将替换文本插入到代码中。
  形式参数的每次出现都将被替换成对应的实际参数。因此，语句：
	x = max(a+b,c+d);
  将被替换为：
	x = a+b*c+d;
 在替换文本中，如果参数名以#作为前缀,则参数将被替换成加双引号的字符串
 例如语句：
 	#define print(expr) printf( #expr "=%g\n",expr)
 使用语句
	print(x/y); 
 调用时将被替换为：
	printf( "x/y" "=%g\n",x/y);

 使用语句
	print("x/y");
 调用时将被替换为：
	printf( \""x/y"\" "=%g\n",\"x/y\");
 
 ##运算符用于连接两个实际的参数，如：
	#define aa(a,b) a  ## b
 调用语句
	aa(name,age);
 将被替换为：
	nameage; //去掉了##前后的空格 

 条件包含
 defined(exp),如果exp已经被定义,其值是1，否则是0
 例句：
  #if !defined(HDR) //如果没有定义HDR
    #define HDR "aaa.h"
  #elif SYSTEM == SYSV //如果系统变量SYSTEM是SYSV
    #define HDR "bsd.h"
  #else
    #define HDR "default.h" 
  #endif
  #include HDR

 C语言专门定义的两个预处理命令
  #ifdef  //如果定义了
  #ifndef //如果没定义

宏定义和类型定义例子：
	#include <stdio.h>
	#define aa int   //预处理的时候使用，遇见aa直接替换为int

	typedef int bb;  //运行时候使用？编译时
	int main(int argc, char **argv){
	    aa cc = 9; // 用预处理声明的int变量
	    bb hh =10; // 用类型定义声明的int变量
	    printf("%d\n",hh);
	}

C数组指针
 int bb[13];
 bb是一个指针，但不是指针变量；bb这个指针指向的是一个int型;
 &bb和bb的值一样，但意思不一样，&bb指向的是一个长度是13的int型的数组;
 所以，如果int占四个字节，那么 bb+1 跨4个字节; (&bb)+1 跨13*4个字节;

 int *bb[13]
 bb是一个指向指针的指针，数组里面的值bb[i]是一个指针，这个指针(bb[i])指向一个int型;

 int (*bb)[13]
 bb指向的是一个长度是13的int型的数组;
 bb+1 的地址跨度是13*4个字节;

C语言结构体
 定义结构:
	struct point{ //定义了一个叫point的结构
		int x;
		int y;
	};
 声明一个结构变量
	struct point cc; //声明了一个cc变量，这个变量是一个结构，这个结构名字是point;
 使用结构： 
	cc.x=12; //为结构成员变量赋值
	cc.y=15;

 匿名结构
	struct {int x; int y;} a={3,4},b={7},c;
 上面这条语句声明了三个变量，每个变量都是一个结构体，结构体中有两个整形的成员变量;

C结构和函数
 结构在函数传递的过程中仍是按值传递: 
	#include <stdio.h>
	struct point {
		int x;
		int y;
	};

	struct point addpoint(struct point p1){
		//结构的传递仍然是传值,所以这里的p1是传进来p1的一个副本
		//在这里对p1的任何操作，不会对外部操作产生影响
		p1.x= p1.x+1;
		p1.y= p1.y+1;
	
		return p1;
	}

	void addpoint_pointer(struct point *p1){
		//p1是一个指向结构体的指针，*p就是这个结构体
		(*p1).x = (*p1).x +1;
	        //为了方便，C语言提供了一种结构指针简写的方式,
        	//可以用 p1->x  代替 (*p1).x
		p1->y = p1->y +1;
	}
	
	//测试结构传递
	main(int argc, char* argv){
		struct point a;
		a.x=3;	
		a.y=4;
	
		addpoint(a);
        	//结构a中成员变量值不变, 保持x=3,y=4
		printf("%d %d\n",a.x, a.y);
	
		addpoint_pointer(&a);
		//结构a中成员变量改变, x=4,y=5
		printf("%d %d\n",a.x, a.y);
	}

位字段
 为了节省空间可以使用一个char或int对象中的位，来标记某个变量；
 例如：某一位是1表示存在某个变量，是0表示不存在等。
   定义一个屏蔽码集合 KEY=01  EXT=02 STATIC=04
 用一个char长度的二进制表示是这样:
   0000 0111 这就表示KEY EXT STATIC都存在

 C语言提供了另一种替代的方法，直接定义位字段
   struct flags{
   	unsigned int is_key:1;  //位字段宽度是1 可以表示 0,1
	unsigned int is_ext:3;  //为字段宽度是3 可以表示 000, 001, 011,101等
	unsigned int is_sta:6;  //位字段宽度是6 可表示 000000, 000001, 000111等
   };
   
   struct flags cc;
   cc.is_key=0;
   cc.is_ext=5; //小于2的三次方

C实现的头文件，在unix系统中一般放在 /usr/include 目录中

C文件操作
 FILE 文件结构，包括：缓冲区位置，缓冲区中当前字符的位置、文件的读写状态、
 是否出错或是否已经到达文件结尾等。

 FILE *fp; //定义一个执行FILE结构的指针fp

 打开一个文件
 	fp = fopen(char *name, char *mode);
        //name是文件名
        //mode是读("r")、写("w")、追加("a")、二进制("b")     
 关闭一个文件
 	fclose(fp);     
 从文件读一个字符
 	int getc(fp); //返回读到的字符，如果结束或出错返回EOF 
 向文件写一个字符
	int putc(c,stdout);//将字符c写入到标准输出，并返回写入的字符，如果出错返回EOF 
 如果流fp中出现错误，则函数ferror返回一个非0值
	int ferror(FILE *fp);//比如输出到磁盘时，磁盘满。
 如果文件fp到达文件尾，返回非零值
	int feof(FILE *fp);

 readfile.c
 	#include <stdio.h>

	//读文件
	main(int argc ,char *argv[]){
		FILE *fp; //指向文件的指针
		void filecopy(FILE *infp,FILE *outfp);
	
		if(argc !=2){
			printf("命令错误，请输入文件名!\n");
			return 1;
		}

		fp = fopen(argv[1],"r"); //打开一个文件
		if(fp == NULL){ //如果发生错误，fopen返回NULL
			printf("文件：%s打开错误!\n",argv[1]);
			return 1;
		}

		int c;
		while((c=getc(fp)) != EOF){ //从文件fp中读一个字符
			putc(c,stdout); //向文件stdout中写入一个字符
		}
	
		fclose(fp); //关闭文件，每个操作系统对程序打开的文件个数都有限制

		return 0;
	} 
  
行输入和行输出 
 //从fp指向的文件中读取一行数据(包括换行符)
 //line 将读取的数据结尾加上'\0'放入line中
 //maxline 读取字符的个数，最多maxline-1个字符？
 //返回值  正常情况下返回line,发生错误或到文件结尾,则返回NULL
 char *fgets(char *line, int maxline, FILE *fp) 

 //将字符串line 写入到文件fp中
 //正常返回非负值，错误返回EOF
 int fputs(char *line, FILE *fp)

 函数gets和puts功能与fgets和fputs函数类似，但他们是对stdin和stdout
 进行操作。gets在读取字符串时，将删除结尾的'\n';而puts在写入时，将加
 上一个'\n'。

#系统接口open、read等和C标准函数库fopen,fgets等函数的区别
	fopen是ANSIC标准中得C语言函数，在不同的系统中(window或linux)调用不同
  的api。在linux中open是系统函数，fopen是其封装函数，fopen最终还是要调用
  底层系统的open函数。
    但是fopen函数在window的实现时就需要调用window的系统函数。
	linux中open、read等系统函数被称为无缓冲I/O函数，用这个函数读写每次都
  要进内核，调用一个系统调用比调用一个用户空间的函数要慢很多，C标准I/O库
  函数会再用户空间开辟I/O缓冲区，省去了自己管理I/O缓冲区的麻烦。

空间分配函数
 //分配n个字节的空间
 void *malloc(size_t n)
 使用：
 	int *a = (int *)malloc(sizeof(int));
        *a = 9;
 //分配n*size个字节的空间
 void *calloc(size_t n, size_t size)
 使用：
	int *p = (int *)calloc(3,sizeof(int));
        *p = 3;
	*(p+1) = 5;
	*(p+2) = 8;

UNIX系统接口
 任何时候对文件的输入输出都是通过文件描述符表示文件，不是通过文件名。
 操作系统在打开一个文件的时候，会返回一个小的非负整数，这个整数就是文件描述符。
 0、1、2分别代表标准输入、标准输出、标准错误输出；任何程序在运行的时候，都会
 打开这个三个文件。
 
系统接口read和wirte
  //fd 文件描述符
  //buf 存放读到的字符
  //n 指定要读多少个
  //n_read 实际读了; 0 表示已到达文件结尾，-1 发生了某种错误 
  int n_read = read(int fd, char *buf, int n);
  
  //fd 要写入的文件描述符
  //buf 要写入的字符
  //n 指定要写多少个
  //n_writen 写了多少个； 如果n和n_writen不相等，表明发生了错误
  int n_writen = write(int fd, char *buf, int n);

  例子：将输入写到输出
  	#include <syscall.h>
	main(){
		char buf[BUFSIZ];
		int n;
		//0 是标准输入的文件描述符
		while( (n=read(0, buf, BUFISIZ)) > 0 ){
			//1 是标准输出的文件描述符
			write(1, buf, n);
		}
	}

系统接口open、creat、close、unlink
 //该函数与标准库函数fopen很相似，不同的是该函数返回的是文件描述符(int类型)，
 //fopen返回的是一个文件指针(FILE *fp)
 //name 要打开的文件名
 //flags 打开方式,int类型; O_RDONLY 只读方式, O_WRONLY 只写方式, O_RDWR 读写方式
		 O_DIRECT 绕过pagecache,直接将数据写入到磁盘
 //perms
 //fd 返回值，如果发生错误，返回-1
 int fd = open(char *name, int flags, int perms);

 //创建一个文件，若存在则覆盖
 //name 要创建的文件的名字
 //perms 创建的文件的权限,如0755
 //fd 创建的文件描述符，若创建失败则放回-1 
 int fd = creat(char *name, int perms);
 
 //断开文件描述符和已打开文件之间的关联
 //一个程序同时打开的文件数通常是20个
 close(int fd);

 //通过文件名删除文件
 //该函数和标准库中的remove对应
 unlink(char *name);

 例子：文件复制
 	#include <stdio.h>
	#include <stdlib.h>
	#include <fcntl.h>
	#define PERMS 0666 //对于所有者、所有者组和其他成员均可读写

	//系统调用 f1复制到f2
	main(int argc, char *argv[]){
		int f1,f2,n;
		char buf[BUFSIZ];

		if(argc != 3){
			printf("参数需要两个文件f1 to f2\n");
			exit(1);
		}
	
		if((f1 = open(argv[1], O_RDONLY, 0)) == -1){
			printf("不能打开文件 %s\n",argv[1]);
		}

		if((f2 = creat(argv[2], PERMS)) == -1){
			printf("不能创建文件 %s, mode %03o\n",argv[2],PERMS);
		}

		while( (n=read(f1,buf,BUFSIZ)) >0 ){
			if( write(f2,buf,n) != n){
				printf("写文件错误 %s\n", argv[2]);
			}
		}
	
		return 0;
	}
 
 随机访问文件
  //fd 文件描述符
  //offset 要设置的文件描述符fd的当前位置
  //origin 0 offset基于文件开始位置; 1 offset基于文件当前位置; 2 offset基于文件结束位置
  //返回值 表示文件的新位置，如果错误返回-1
  long lseek(int fd, long offset, int origin);

标准输入stdin是有缓冲区的，比如标准函数 getc(stdin);
 例如程序: 
	int c = getc(stdin);
	c = getc(stdin);
 第一次访问的时候，因为还没有缓存区，所以会先创建缓存区，再调用系统函数read填充次缓冲区，
 这时会等待用户输入数据，比如输入为"abcdef",则会返回第一个字符'a'。
 第二次访问的时候，因为缓冲区里面已经有数据了，所以会从缓冲区中取出第二字符'b'。
 当缓冲区中的数据被全部取出后，如果再次调用函数getc(stdin),会再次要求用户输入数据。


------------------------------------CSAPP-------------------------------------
P ^ T = ~P //P异或True结果是非P

无符号数的编码
 假设一个整数用w位表示，则可以写成[x_(w-1),x_(w-2),...,x_(0)]  //_(w-1)是x的下标,
 B2U_w(Binary to Unsiged)二进制到无符号数的表示法。
 例子：
	B2U_4[0110] = 0*2的3次方  + 1*2的二次方 + 1*2的一次方 + 0*2的零次方 = 6 

补码编码，有符号数的表示
 这里一个关键是把字的最高有效位解释为负权
 B2T_w(Binary to Two's-complement)二级制的有符号数表示法
 例子
	B2T_4[0010] = -0*2的3次方 + 0*2的二次方 + 1*2的一次方 + 0*2的零次方 = 2
        B2T_4[1010] = -1*2的3次方 + 0*2的二次方 + 1*2的一次方 + 0*2的零次方 = -8+2 = -6
 有符号的表示法就是最高位加上一个负号

强制类型转换的结果保持底层的位值不变，只是改变了解释这些位的方式
 假设int是用8位表示
 int v = 1000 0001 = -128 + 1 = -127  //二进制表示，容易说明
 unsigned uv = (unsigend)v;     //位模式不变，解释发生改变,转换后 uv = 128 + 1 = 129;

从补码到无符号数的转换T2U_w,相当于把负号变成了2的w次方;原来的十进制值加上2的w次方。
 例如:假设int是8位
     int v  =  -123;
     那么转换成无符号uv就是: 2的8次方+(-123) = 133;
从无符号数到补码的转换U2T_w
 对于大于等于2的w-1次方的数，都会转换成负数；
 如果要转换的无符号数大于等于2的w-1次方，那么相当于当前数值减去2的w次方
 例如：假设int是8为
    unsigned int uv = 133;
    int v = (int)uv; //有符号的v = 133 - 2的八次方 = -123

当执行一个运算是，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会
隐式地将有符号参数强制类型转换为无符号数。
  例如：-1 < 0U; 会返回0(false)

看一个类型转换的例子
  //占用两个字节16位，因为是负数，所以坐高为是1 
  short sx = -12345; 
  //sx会首先扩大长度,变成32位,执行符号扩展,所以多出的16位全是1,然后转成无符号的
  unsigned uy = sx;  /*4294954951*/

C语言中对于任意整数值x,有 -x = ~x +1;
 例子：
	int x = 8;
	-x = ~x + 1 = -8;

直接补码乘法，以下的二进制我们都用的是补码，切符号位用圆括号括起来。
 例子：
	-3 = (1) 1 0 1  //符号位(1)
	 7 = (0) 1 1 1  //符号位(0)
 如果有负数，需要将其转换为整数，然后再乘:
							 0      0     1     1 = 3
					*	     0      1     1     1 = 7
	  ---------------------------------------------------------------------------------------------------
		    	             0      0     1     1
					  0      0      1     1  
			    0     0      1      1     
      + 0       0     0      0                       
  ---------------------------------------------------------------------------------------------------
        0      0      1      0      1     0     1      //再转换成补码；求反加1
		1	   1	  0		 1		0	  1		1      //
      -1*64 + 1*32 + 0*16 + 1*8  + 0*4 + 1*2  + 1*1 = -21 

直接补码加法和乘法类似
  例子：
	-3 = (1) 1 0 1  //符号位(1)
	 7 = (0) 1 1 1  //符号位(0)
  做加法
	 	      (1)     1     0     1
          +   (0)     1     1     1 
      ------------------------------------------------------------------------
               0      1     0     0
             -0*8 +  1*4 + 0*2 + 0*1 = 4

执行算数右移舍入的问题
  正常情况下右移k位表示除以2的k次幂函，
  对于正数来说会向接近零的方向舍入，例如：
	7 >> 1 = 3
  对于负数来说会向远离零的方向舍入，例如：
 	-7 >> 1 = -4
  
  对某个数加上一个偏移量，会改变舍入的方向
  偏移量为2的k-1次幂
  假设：k=1 2的k-1次幂是1
  对于正数，则会向者远离零的方向舍入，例如：
 	7 + 1 >> 1 = 4
  对于负数，则会向着接近零的方向舍入，例如：
	-7 + 1 >> 1 = -3

C语言编译器gcc
 gcc -O1 -S code.c
 -Wall 打开所有类型的语法警告
 -pedantic 严格发出ansi c 标准的警告,可以打印出-Wall以外更多的警告信息
 -O1 告诉编译器用一级优化
 -O2 二级优化
 -O3 三级优化
 -Os 生成短小的机器码
 -S  获取C语言编译器产生的汇编代码(.s)
 -c  汇编该代码,即产生一个.o的文件,不链接
 -o  指定输出文件名，默认是a.out
 -E  仅对代码做预处理不编译。将头文件包含和宏定义展开。
     如果没有用-o指定输出文件名则将预处理的结果输出到控制台。
 -m32 32位编译
 -m64 64位编译
 -g  生成用于debug的信息
 -std 指定c的版本
	例如：
	-std=gnu89			GNU 89
	-ansi,-std=c89		ANSI,ISO C90
	-std=c99			ISO	C99
	-std=gnu99			GNU 99
 -I  指定头文件的目录
 -nostdinc 编译器不在系统缺省目录中找头文件
 -M  打印.c文件引用的所有.h头文件
 -MM 打印.c文件应用的所有非系统头文件
	例子:
	$gcc -MM strbuf.c
     strbuf.o: strbuf.c strbuf.h
 -D<macro> 定义宏
	例子:
	$gcc -Dabc
     相当于C中的 #define abc
    
    $gcc -Dabc=444
	 ---> #define abc 444
 -U<macro> 取消宏定义
	例子:
	$gcc -Umacro
	 ---> #undef macro
 -l<libname> 指定编译的时候使用的库名字,当使用的库文件不在默认路径下时
    可以配合-L参数一起使用.
 	例子:
	$gcc -llua hello.c
	使用liblua.so或liblua.a库文件编译程序
 -L<dir> 指定编译时搜索库文件的路径; -I是搜索.h用的。
	如:
	$gcc -L/my/path -labc hello.c
    该程序在链接时会先从指定路径中搜abc.so或abc.a库文件

gcc查找头文件的路径
 1.对于#include "a.h"这种形式,gcc在当前路径下找。
 2.对于#include <a.h>这种形式,gcc的寻找顺序如下:
	a)从gcc指定的路径中查找,如：
		$gcc -I /abc
      则从/abc下找a.h这个头文件
    b)从gcc的环境变量中找:
		C_INCLUDE_PATH/CPLUS_INCLUDE_PATH/OBJC_INCLUDE_PATH
    c)从系统缺省目录中找
		/usr/include	
		/usr/local/include
    	/usr/lib/gcc/x86_64-redhat-linux/4.4.4/include
      注意:最后一个路径是gcc程序的库文件地址,不同的系统上可能不一样

gcc查找库文件的路径
 1.从gcc指定的目录中搜索,如:
   $gcc -L /my/path
 2.如果找不到则从gcc的环境变量LIBRARY_PATH中找
 3.从以下目录中找
   /lib
   /usr/lib
   /usr/local/lib

 ??为什么自己写的chash在mac下需要指定-llua参数,在linux下就不需要?? 
	     

反汇编器objdump可以将目标代码,反汇编成汇编格式的代码
 objdump -d dest.o
mac用otool工具
 otool -tV dest.o

CPU八个常用32位寄存器
 EAX : extend accumulator   累加寄存器
 ECX : extend counter  计数寄存器
 EDX : extend data 数据寄存器
 EBX : extend base 基址寄存器
 ESP ：extend stack pointer 栈指针寄存器
 EBP : extend base pointer 基址指针寄存器
 ESI ：extend source index 源变址寄存器
 EDI ：extend destination index 目的变址寄存器

条件码寄存器
 CF : carry flag 进位标志位。最近的操作使最高位产生了进位。可以用来检测无符号操作数的溢出。
 ZF : zero flag 零标志位。最近的操作得出的结果为0.
 SF ：sign flag 符号标志位。 最近的操作得到的结果为负数。
 OF ：overflow flag 溢出标志。 最近的操作导致一个补码溢出--正溢出或负溢出。
 
补码加法正溢出
 当整数x+y的和大于该整所能表示的最大正数时，产生正溢出

补码加法负溢出
 当整数x+y的和小于该整数所能表示的最小负数时，产生负溢出
 
栈针的结构
                     栈底
				|     .       |
				|     .	      |  
				|     .	      |                 较早的帧
				|             |
                |		      |  
  old %ebp  --> |_____________| ______________________________________________
				|     .	      |
				|     .       |
				|     .       |
				|-------------|
				|   参数n     |                调用者的帧
				|-------------|   这些参数是调用着要传给被调用者的值。
                |     .       |   被调用者使用这些参数的时候可以通过%ebp，
				|-------------|   %ebp+2就是第一个参数的地址。
				|   参数1     |
				|-------------|
				|  返回地址   | --->pc要用到的,是当被调用者返回后,要继续执行的地址 
				|_____________|  ___________________________________________
 帧指针%ebp --->| 老帧指针值  |
				| old %ebp    |
				|-------------|
				|             |
                | 被保存的    |
				| 寄存器、    |
				| 本地变量、  |
				| 临时变量等  |                当前帧
				|             |
				|-------------|
				|             |
				| 参数构造区域|
				|             |
 栈指针%esp --->|	 	      |  _____________________________________________

过程调用和返回指令格式
	call Label      过程调用	
        call *Operand   过程调用
        leave           为返回准备栈
        ret             从过程调用中返回
 call指令得效果是将返回地址入栈，并跳转到被调用过程的起始处(更改pc值)。
 leave指令的效果是将%esp设置为，当前%ebp的上一个地址，即返回地址.效果如下：
    movl %ebp, %esp  //将当前帧地址设置为栈顶,此时栈顶存的是上一个方法的，帧的开始位置(old %ebp)。
    popl %ebp        //将 %ebp 还原为 old %ebp,%esp指向返回地址(调用者调用call指令的下一个地址)。
 ret指令的效果是将栈顶的返回地址，放入pc中。
 
 GCC产生的代码有时候会使用leave指令来释放栈帧，有时会用一个或两个popl指令。两种方法都可行。
 这两种方法的作用都是将%esp指向返回地址，然后ret指令就可以引用到栈顶得返回地址。

部分指令解释：汇编出的格式是AT&T汇编,和其他汇编不同的时dst和src是反过来的
 movl  $5,-8(%ebp);		//给位于%ebp-8地址的局部变量赋值5 
 movl  (%eax),%edi;		//将%eax作为地址指向的内容放入到%edi中
 movl  %eax,%edi;		//将%eax的内容让如到%edi中
 movl  %eax,-12(%ebp);	//将%eax的内容放入到%ebp-12地址的地方
 leal  -12(%ebp),%esi	//和上面的例子不同，这个是直接将%eax-12作为内容放入到%esi中
 popl  %ebp;			//将栈顶数据弹出，放入%ebp
 
寄存器使用惯例
 %eax、%edx、%ecx //需要调用者保存的寄存器。在调用其他方法时，需要把这三个寄存器的值保存起来。
 %ebx、%esi、%edi //需要被调用这保存。如果要使用，则需将其保存。返回前需恢复它们。 	

GCC方法编译后有三部分组成
 1.建立部分：
   pushl  %ebp        //保存老的%ebp,此时栈顶指向保存old %ebp的地址
   movl   %esp, %ebp  //将此时的栈顶地址，设置为当前方法的帧指针,%esp->%ebp
   pushl  %ebx        //保存 "调用者保存的寄存器"的值，如果下面有用到才会保存
   pushl  %edi		  //同上
   pushl  %esi		  //同上
   subl	  $100, %esp  //调整栈指针,乡下移动100个字节,给局部变量用
 2.主体部分：
   addl   %ebx, %eax
 3.结束部分：
   leave      //为返回准备栈
   ret        //返回

数据对齐  //可以提高效率，可以用移位等操作代替乘法等操作
 linux沿用的对齐策略是,2字节数据类型的地址必须是2的倍数，也就是地址的最低位必须是0。1010
 较大数据(int、int*、float、double)的地址必须是4的位数，地址最低方位必须是0。1100
 一个字节的数据就按1的倍数。
  例子：
	struct S1{
		int i;
		char c;
		int j;
	}
  如果不用对齐，编译器用最小9字节分配，如下图：
	 	偏移 0	  4 5    9
             -------------
        内容 | i  |c| j  |
             --------------
  按4字节对齐，会分配12字节，如下图：
		偏移 0	  4    8    12 
             ----------------
        内容 | i  |c   | j  |
             ----------------
  例子2：
	struct S1{       //起始地址
		int i;   //0
		int j;   //4
		char c1; //8
		char c2; //9
		char c3; //10
	}//分配12个字节，因为char的地址按1的倍数对齐就可以，这个结构换可以在最后放一个char类型。

        struct S2{        //起始地址
		int i;    //0
		char c1;  //4
		int j;    //8 int地址要按4的倍数对齐，所以前一个c1浪费了三个字节
		char c2;  //12
		char c3;  //13
	}//分配16个字节,整个结构是4字节对齐.
	 //以上结构的对齐在32位和64位是一样的.
         //32位编译器会按最大4字节来对齐结构.
	 //64为编译器会按最大的数据类型来对齐结构.

  所以合理安排结构体成员的顺序，可以节省空间(编译器可能会做这方面的优化)。
  
函数指针的值是该函数机器代码表示中第一条指令的地址,例如：
     int fun(int,int *p);//这是一个函数，接收参数并返回整形
     int *f(int,int *);//这是一个函数，接收参数并返回一个指针，该指针指向一个整形
     int (*fp)(int,int *);//函数指针变量,指向一个函数,该函数接收一个整形和一个整形指针为参数,返回一个整形
     fp = fun;  //这个函数的第一个指令地址赋值给这个变量
     fp = fp+1; //fun函数的第二个指令地址

64位过程
 没有帧指针ebp；作为替代，对栈位置的引用相对于栈指针。
 大多数函数在调用开始时分配所有需要的整个栈存储，并保存栈指针指向固定位置。

64为参数传递
 最多可以有6个整型(整数和指针)参数可以通过寄存器进行传递。寄存器按指定的顺序指定。
 如图：
		-----------------------------------------------------|
		操作数大小 |               参数数量                  |
                   |   1      2	     3	    4	  5   	 6   |
		-----------------------------------------------------|
	   	    64     | %rdi | %rsi | %rdx | %rcx | %r8  | %r9  |
        -----------------------------------------------------|
            32     | %edi | %esi | %edx | %ecx | %r8d | %r9d |
        -----------------------------------------------------|
	    	16     | %di  | %si  |  %dx | %cx  | %r8w | %r9w |
		-----------------------------------------------------|
             8     | %dil | %sil | %dl  | %cl  | %r8b | %r9b |
        -----------------------------------------------------|
 在16个通用目的寄存器中，6个用来传参数，6个(%rbx,%rbp,%r12~%r15)是被调用这保存，
 1个(%rax)保存函数的返回值,一个(%rsp)作为栈指针，剩下两个(%r10,%r11)调用者保存。

x86-64 ABI指明程序可以使用当前栈之外128字节的范围(即低于当前栈指针的值).

x86-64对齐要求
 对于任何需要K字节的标量数据类型，它的起始地址必须是K的倍数。

连接器如何解析多重定义的全局符号
 强符号：函数和以初始化的全局变量
 弱符号：未初始化的全局变量
 
 1.不允许有多个相同的强符号
 2.如果有一个强符号和多个弱符号，那么选择强符号
 3.如果有多个相同弱符号，那么从这个弱符号中任意选择一个

与静态库连接
 当连接器构造一个输出的可执行文件时，它只拷贝静态库(.a结尾)里被应用程序引用的目标模块
 (静态库和可重定位目标文件*.o是不一样的，用目标文件的时候是全部拷贝)

 使用方法：
    gcc main.c /usr/bin/libc.a
 C编译器驱动程序总是传送静态函数库libc.a给连接器，所以对libc.a的引用是默认的
 
 libc.a静态库包含printf.o模块，以及printf.o调用的其它的模块，stdio.h头文件中，
 有对printf.o模块中printf函数的原型声明

重定位条目
 typedef struct{
	int offset; //要修改的引用地址的偏移量
	int symbol; //引用的符号
	type;       //该引用的类型
 }Elf32_Rel;

A)重定位PC相对引用
 如果type=R_386_PC32
 用32位编译器(main.o 中调用 swap.o中的swap方法)
    main.o 中main函数所在节的地址 400480
    swap.o 中swap函数所在节的地址 4004a0
 那么对于这样一条指令：	
        11:e8 fc ff ff ff     call   12 <main+0x12> //此时偏移量是0x12，说明这个地址是需要修改的
        16:83 c4 04           add    $0x4,%esp
 连接器最终会将修改e8后面的地址，修改过程像这样：
   将call指令所在的.text节的地址 +偏移量offset(0x12)，设该值为refaddr
   最后将offset指定的偏移地址位置的值，修改为:   
   swap符号在所在节的地址ADDR(r.symbol) - refaddr + 当前引用值(fc ff ff ff)
   结果:                0x4004a0 - (0x400480+0x12) + (-4) = 10 
   也就是链接后swap函数地址是，紧跟这个call指令的地址+10
 
 64位编译器和32稍有差别，用上面同样的程序举例
 编译出的指令是这样的:
   6:e8 00 00 00 00       callq  b <main+0xb> //直接指向了call的下一条指令,e8后面全是零
   b:31 c0                xor    %eax,%eax
 连接器用同样的算法修改e8后面的地址
   4004a0(swap函数地址) - (0x400480+0xb) + (0) = 15
 注意：
    用64位编译后的代码，对offset的解释就有点蹩脚。
    offset原定义是需要被修改的引用的节偏移，也就是说需要被修改的起始地址的值

 函数引用解析的过程：
  比如当前程序引用了一个外部的swap函数(假设所有重定位目标集合E已经完成)
  1.连接器在查看当前符号表的时候(已经放在一个未解析的符号集合U中)，看到swap这个符号是一个对外部的引用。
  2.去.rel.text这个表中找swap这个符号。迭代所有目标文件的符号表(已经放在一个已定义符号集合D中),获取swap符号的地址。
  3.存在这个符号，根据.rel.text表中这个符号的相关条目信息，修改当前程序中对swap符号的引用为swap的地址。
  链接的关键是通过.rel.text表，找到swap这个符号的绝对地址。
  

符号表.symtab用来存放一个目标文件中定义和引用的函数和全局变量的信息,只记录这个符号的定义出现的位置。
如果是一个外部引用，就需要用到.rel.text(引用外部函数)或.rel.data(全局变量)表，这个表记录了当前引用
的偏移量(offset),引用的符号symbol,引用类型type。

动态链接共享库
 共享库不会复制到可执行目标文件，而是在第一次加载后固定一个位置，此后所有用到共享库中数据的可执行文件，
 都会被动态链接器链接到特定位置。
 
 Unix通常用.so(dynamic object)后缀表示,window用dll(动态链接库)
 unix> gcc -shared -fPIC -o shardlib.so add.c swap.c  //创建共享库
 unix> gcc main.c ./shardlib.so //创建一个可以在加载时动态链接的可执行文件
 
 从应用程序中加载和链接共享库

IO发生时涉及的对象和步骤
 针对一个network IO(read操作)，涉及两个系统对象，一是调用此IO的进程或线程，
 另一个是系统内核。系统内核执行read操作时，会经历两个阶段：
   1.等待数据准备
   2.将数据从内核拷贝到进程中
 IO Model的区别就体现在这两个阶段的不同情况

 执行阶段1时，让用户程序等待返回和直接返回，体现block和non block,
 不管是block还是non block,第二阶段总是阻塞的。

 如果在read的时候,1、2都不阻塞，直接返回，等数据拷贝到进程中后通过通知或回调等方式
 通知应用程序，这种是异步IO(AIO)

异常控制流(Exceptional Control Flow,ECF)
 现代操作系统通过使控制流发生突变来对这些情况作出反应，我们把这些突变称为异常控制流。
  
 处理器有多种状态，这种状态被编码为不同的位和信号。状态变化称为事件。
 事件可能和当前指令相关，比如发生虚拟存储器缺页、算术溢出等。
 也可能和指令不想关，比如系统定时器产生的信号或一个IO请求完成。

 处理器中有一张异常跳转表，这张表记录了什么样的异常，应该执行什么样的异常程序(异常处理程序(exception handler))。
 异常处理程序运行在内核模式下。
 异常处理程序，根据事件类型(中断、陷阱、故障、终止)来决定原程序如何执行:
 1)处理程序将控制返回给当前指令(发生事件时正在执行的指令).
 2)将控制返回给下一条指令(原程序没发生事件时将要执行的下一条指令)
 3)终止被中断的程序.
 
 系统中每种类型的异常都有一个唯一的非负整数的异常号：
 这些号码，有些是硬件分配的，如缺页、断点、算术溢出等。
 有些是操作系统内核分配的，如系统调用、外部IO设备信号等。
  
异常的类别
 中断：
    中断是异步发生的，来自处理器外部的IO设备的信号的结果。硬件中断不是任何一条指令造成的,所以
    说它是异步的。
    IO设备通过向处理器芯片上的一个引脚发信号，来中断异常：当前指令完成后处理器检查中断引脚电压，
    以此来响应中断。
 剩下的异常类型是同步发生的，都是执行当前指令的结果，这些指令叫做故障指令(比如，int n指令，专门用于系统调用)。
 陷阱：
   陷阱是有意的异常，是执行一条指令的结果(如,int n指令).
   陷阱主要的用途是在用户程序和内核之间提供一个像过程一样的接口，系统调用。
   系统调用很耗费资源，需将用户模式转为内核模式，内核程序还需要保存用户程序的一些寄存器等状态。
   信号就是用陷阱实现的，是一种更高层次的软件形式的异常。
   
   如何实现信号：
   假设我们有一个发送信号的函数kill,该函数是一个系统调用，那么它就是一个陷阱异常。
   当我们调用kill这样一个函数的时候，当前程序会转到陷阱异常处理程序，在陷阱异常处理
   程序中，我们可以辨别出是一个信号函数，然后根据其参数来分辨是发给什么进程的什么信号，
   然后更改那个进程的PC的值，使得那个进程可以立即响应该信号。 
   每个进程都有一个对应的信号处理函数(handler),这个函数可能是默认的，也可能是用户指定的。
   在响应信号时更改的PC值，应该是这些信号处理函数的地址。
 故障：
   故障有错误情况引起，它有可能被故障处理程序修正。
   比如一个缺页异常，当指令应用一个虚拟地址，但与该地址对应的物理页面不在内存中，需从磁盘取，
   这时就会发生故障。这时候故障程序会通知缺页程序去加载数据，完成后将控制返回给引起故障的指令。
   如果不能恢复，故障程序返回到内核的abort程序，改程序终止引起故障的程序。
 终止：
   终止是不可恢复的致命错误造成的，一般是一些硬件错误，终止程序直接调用abort程序，终止当前应用。

Linux/IA32系统中的异常号
  0 ~ 31: Intel架构师定义的异常
  32~255: 操作系统定义的中断和陷阱

Linux/IA32系统调用
 每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量。
  ----------------------------------------------------------------------------------
    1   exit    结束进程                  27    alarm     设置传送信号的警告时钟
    2   fork    创建新进程                29    pause     挂起进程直到信号到达
    3   read    读文件                    37    kill      发送信号到另一个进程
    4   write   写文件                    48    signal    安装一个信号处理程序
    5   open    打开文件                  63    dup2      复制文件描述符
    6   close   关闭文件                  64    getppid   获得父进程ID
    7   waitpid 等待子进程结束            65    getpgrp   获得进程组
    11  execve  加载和运行程序            67    sigaction 安装可移植的信号处理程序
    19  lseek   定位到文件偏移量处        90    mmap      将存储器页映射到文件
    20  getpid  获得进程ID                106   stat      获得有关文件的信息
  -----------------------------------------------------------------------------------

为当前进程设置信号处理函数
  signal(signal,function) //如果进程收到一个signal信号，就异步调用function函数
  signal(signal,SIG_IGL)  //忽略类型为signal的信号
  signal(signal,SIG_DFL)  //恢复类型为signal的信号的默认行为
  注意：SIGSTOP和SIGKILL两个信号的默认行为，不会通过上面三种方式被修改
给自己发送信号,进程可以通过调用alarm函数向它自己发送SIGALRM信号
  unsiged int alarm(unsigned int secends);
  返回值：前一次闹钟剩余的秒数，如果以前没有设置则返回0; ?前一次的设置是否还有效。
  secends: 多长时间后发送信号.

发送信号
 内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。
接收信号
 当前进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。

外壳为每个作业(job)创建一个独立的进程组
 且每个作业的进程号pid就是它所属的进程组号gpid。
 外壳用:
	execve(const char *filename, const char *argv[], const char *envp[])
 来调用程序，execve加载了filename之后，调用启动代码。启动代码会将控制传递给新程序的
 主函数：
 	int main(int argc,char *argv[],char *envp[])

子进程回收
  int waitpid(int pid, int *status, int options);
  //等待某个子进程结束，成功返回后会将这个已终止的子进程从系统中清除
  //如果主进程没有子进程，返回-1，并且设置errno为ECHILD.如果waitpid被一个信号中断，
  //那么返回-1，并设置errno为EINTR.
  知识点：
    系统函数read,可能就是创建一个子进程去准备数据，然后用waitpid阻塞主进程。这个时候
   如果主进程收到一个中断信号，那么waitpid就会提前返回-1，并且errno为EINTR。
   但是子进程并没有将数据准备好，所以就可能会导致read提前返回。对于这种情况不同的系统
   处理的方式不一样，linux会再次调用read函数，确保可以返回正确的数据，在特定的Solaris系统中
   会直接返回一个错误。

用SIGCHLD信号回收子进程，这样子进程运行的时候，主进程也可以做其它的事
  例子：
    int main(){
	signal(SIGCHLD,handler);//为主进程绑定一个信号处理函数
       
        int pid = fork();
	if(pid == 0){ //子进程
		//TODO something
		exit(0);
		//当该子进程终止的时候，会向主进程发一个SIGCHLD信号，然后handler函数运行。
	}
        
        read();//读一些数据  这个过程可能被信号中断，不同系统有不同处理
        while(1){
	   //do something 这个过程可能被信号中断
	}
       
    }
    //回收子进程的函数,这个函数会在主进程中并行的执行
    void handler(int singnal){
	int status;
	int pid;
        
        //在这个信号处理函数中，waitpid会被一个信号中断吗？
        //感觉不会，因为这已经是主进程在处理信号了，如果有相同的信号它不会接收，
        //不同的信号也不应对这个产生影响.
        //主进程会并行的处理不同的信号.
        while(waitpid(-1,&status,0) > 0){ //尽可能多的回收子进程
            //这样可以避免多个子进程同时终止时，发生信号丢失的情况 
        }
        
        //waitpid返回-1代表发生错误终止，同时如果errno等于ECHILD代表是因为没有子进程了
        //如果不是ECHILD说明是其他错误. 
	if(errno != ECHILD){
		//不是正常终止的
	}         
           
	return;	
    }

非本地跳转 <setjmp.h>
  int setjmp(jmp_buf env);
  int sigsetjmp(sigjum_buf env, int savesigs); //信号
  调用一次返回两次;如果返回零那就是自身返回的，如果返回非零就是longjmp返回的。
  
  int longjmp(jmp_buf env,int returnvalue); 
  int siglongjmp(sigjmp_buf env, int returnvalue); //信号
  从不返回到自身，返回到setjmp处(或者理解成，该函数导致setjmp的第二次返回,值是returnvalue);
  注意：这两个方法好像需要在同一个进程中配合使用

Unix用三种数据结构表示打开的文件
 描述符表：每个进程都有独立的描述符表，每个项指向一个文件表的表项
 文件表：所有进程共享这张表。每个表项包括文件当前的位置，被引用的个数(有多少个描述符指向这个文件项)
	以及一个指向v-node表项的指针。
 v-node表:所有进程共享这样表。每个表项包括文件访问、文件大小、文件类型等
 
                    描述符表(每个进程一个)
						------------
                    fd0 |          |       打开的文件表(所有进程共享)       v-node表(所有共享)
                        ------------                                          
                    fd1 |          |             ----------                    --------
                        ------------             |文件位置| 文件A              | 大小 |         
                    fd2 |          |             ----------                    -------- 文件aa.txt
                        ------------             ----------                    | 类型 |
                    fd3 |          |             |文件位置| 文件B              --------
                        ------------             ----------
    注意:不同的文件描述符可以指向相同的文件表项;文件A和文件B也可以同时指向同一个v-node表项。
	当用open打开一个文件aa.txt两次的时候，会产生两个文件描述符、两个文件表项、一个v-node表项。
	当调用fork后，子进程仅会有父进程描述符的副本，所以子进程会共享父进程的打开的文件、包括位置.	

I/O重定向
  所谓的IO重定向，就是将一个文件描述符拷贝到另一个描述符
  例子,将标准输入重定向到一个磁盘文件aa.txt
   假设目前：
     fd0(stdin) --> 文件A --> 屏幕
     fd3  --> 文件B --> 文件aa.txt
   调用函数dup2(fd3,fd0),意思是将fd3这个描述符拷贝到fd0这个位置
   结果就是fd0和fd3都指向了文件B，并且如果文件A的引用数为0，那么文件A这个表项将被删除。



网络字节顺序的转换函数 <netinet/in.h>
 //将无符号长整型的主机字节顺序，转换为网络字节顺序(大端法)
 unsigned long int htonl(unsigned long int hostlong);
 //将无符号短整型的主机字节顺序，转换为网络字节顺序(大端法)
 unsiged short int htons(unsigned short int hostshort);

 //网络字节顺序转主机字节顺序
 unsigned long int ntohl(unsigned long int netlong);
 unsigned short int ntohs(unsigned short int netshort);

网络ip地址和点分十进制互转 <arpa/inet.h>
 //将点分十进制串(*cp)转换为网络ip地址(*inp)
 //成功为1，出错为0
 int inet_aton(const char *cp, struct in_addr *inp);
 //将一个网络ip地址(in)转换为点分十进制字符串，返回值是指向这个串的指针
 char *inet_ntoa(struct in_addr in);

从DNS数据库中获取主机条目 <netdb.h>
 //获取*name这个域名对应的DNS条目
 //出错返回NULL指针，并设置h_errno
 struct hostnet *gethostbyname(const char *name);
 //*addr 点分十进制字符串
 //len ip地址的字节长度
 //出错返回NULL指针，并设置h_errno
 struct hostnet *gethostbyaddr(const char *addr,int len, 0);

两种套接字结构
   struct sockaddr{ //一般类型的套接字地址结构
   	unsigned short sa_family;
	char 	       sa_data[14];
   }
   
   struct sockaddr_in{ //<netinet/in.h>互联网类型的套接字地址结构,我们用这个赋值，
					   //然后强转成sockaddr,传给需要的套接字函数
	unsigned short sin_family;  //AF_INET
	unsigned short sin_port;    //套接字端口
	struct in_addr sin_addr;    //套接字地址
	unsiged char   sin_zero[8]; //?	
   }

DNS条目结构   
   struct hostent{  //DNS 条目结构
	 char *h_name;       //正式的域名
   	 char **h_aliases;   //别名？
	 int  h_addrtype;    //主机的地址类型 AF_INET?
     int  h_length;      //这个地址的长度，单位字节
	 char **h_addr_list; //这个域名对应的所有ip地址(点分十进制)
   } 

IP地址结构
 struct in_addr{
 	unsigned int s_addr;
 }


创建一个套接字描述符 <sys/types.h> <sys/socket.h>
 //domain:AF_INET  代表因特网
 //type:SOCK_ATREAM 表示该套接字是因特网的一个端点
 //protocal:0
 //返回套接字描述符，出错则-1
 int socket(int domain, int type ,int protocol);

客户端和服务器连接 <sys/socket.h>
 //客户端和服务器建立连接
 //sockfd 客户端套接字描述符
 //*serv_addr 服务端套接字地址 (一般结构表示法) 
 //addrlen  sizeof(sockaddr_in)  网络结构表示法的 结构长度
 //成功返回0，出错则为-1
 int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);

服务器和客户端建立连接，需要bind、listen、accept这三个函数 <sys/socket.h>
 //配置服务器
 setsockopt()
 
 //sockfd 通过socket函数创建的，用于监听的，服务端的套接字描述符
 //*my_addr 服务端的套接字地址，需要我们自己赋值
 //addrlen sizeof(sockaddr_in)
 //成功为0，出错为-1
 int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
 
 //将sockfd转化为一个监听套接字
 //backlog 等待队列的大小
 //成功返回0，出错为-1
 int listen(int sockfd, int backlog); 

等待客户端的连接请求 <sys/socket.h>
 //listenfd 监听的描述符
 //*addr 该函数要填写的客户端套接字地址
 //*addrlen 该函数负责填写
 //返回连接描述符，出错返回-1
 int accept(int listenfd,struct sockaddr *addr, int *addrlen);


服务器端监听端口的例子：
 #include <stdio.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <stdlib.h>
 #include <netinet/in.h>
 #include <string.h>

 int main(int argc, char **argv){
	//创建套接字描述符
	int listenfd = socket(AF_INET,SOCK_STREAM,0);

	//int optval=1;
	//setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,(const void *)&optval,sizeof(int))//设置socket一些配置
	
    //指定特定ip地址
	struct in_addr inaddr;        
	if(inet_aton("10.12.212.86", &inaddr) == 0){ //此时已经是网络字节顺序
		printf("点分十进制ip转网络ip地址错误!");
		return -1;
	}
    //所有ip地址
    //inaddr.s_addr = htonl(INADDR_ANY); //主机字节顺序转网络字节顺序，这台主机所有ip地址       
	
    //服务器socket地址
    struct sockaddr_in serveraddr;
    //从指定地址开始为套接字清零，第二个参数是要清零的字节个数
	//bzero((char *)&serveraddr,sizeof(serveraddr));
    serveraddr.sin_family = AF_INET;
	serveraddr.sin_port = htons(8001);    //主机字节顺序到网络字节顺序转换
	serveraddr.sin_addr.s_addr = inaddr.s_addr;
 
    //listenfd描述符和服务端套接字地址绑定
    int bi = bind(listenfd,(struct sockaddr *)&serveraddr,sizeof(serveraddr));
    if(bi < 0){
		printf("绑定失败！\n");
		return -1;
 	}
        
    //开始监听
    int li = listen(listenfd,1024);        
    if(li < 0){
		printf("监听失败");
        return -1;
	}

    //等待接受客户端请求
    struct sockaddr_in clientaddr;  //客户端套接字地址
    int addrlen;                    //套接字地址的字节个数
    int connfd = accept(listenfd,(struct sockaddr *)&clientaddr,&addrlen); 
 
    //从套接字描述符读数据
    while(1){
	  char c[]={0,'\0'};
      read(connfd,c,1);
      printf("%s",c);	
	}
    //关闭 套接字描述符
    close(connfd);
    close(listenfd);	
 }

#IO多路复用中select的解释
 int select(int n,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,struct timeval *timeout);
 参数说明:
 n: 要监视的描述符的做大值+1
 readfds: 监视该集合中的描述符是否有数据可读(即该集合中的描述符可以无阻塞完成)
 writefds: 监视该集合中描述符是否可以无阻塞写
 exceptfds: 监视该集合中得描述符是否发生异常
 timeval: 设置等待时间
 返回值：如果成功则返回就绪的描述符的个数。如果超时则返回可能是0.
	出错时返回-1，同时会设置errno

 其中三个集合都可以是NULL，意味着什么也没监听。
 例如：
	int maxfd = 9;
	fd_set readfds;
	int ret = select(maxfd+1,&readfds,NULL,NULL,NULL);
	每次调用select的时候都会把readfds中可用的描述符放入到readfds中。
    所以我们在实际使用的时候想这样：
	fd_set readfds;
	fd_set initfds;

	//首先将要监控的描述符放入initfds中
    FD_SET(0,&initfds);
	FD_SET(1,&initfds);
	
	while(true){
		readfds = initfds; //这样每次都会监控初始化的描述符
		int ret select(2,&readfds,NULL,NULL,NULL);

		//do something 
		//like FD_ISSET(0,&readfds);
	}

#IO多路复用poll的解释
  int poll(struct pollfd *fds,nfds_t nfds,int timeout);
  fds: 是个结构体，每个fds代表一个文件描述符
  nfds_t: fds代表的结构体的个数
  timeout: 超时时间
  返回值：成功时返回可用的描述符的个数。如果没事件发生且超时则返回0。
	失败时返回-1，且设置errno值。

  //fds代表的结构体
  struct pollfd{
	int fd;			//文件描述符
	short events;	//要监控的事件
	short revents;	//可用的事件
  }
  
  例子：
	#include <stdio.h>
	#include <unistd.h>
	#include <poll.h>	
	#define TIMEOUT 5

	int main(int argc,char *argv[]){
		struct pollfd fds[2];	//要监控两个文件描述符
		int ret; 	//返回值
		
		/*监控标准输入描述符*/
		fds[0].fd = STDIN_FILENO;
		fds[0].events = POLLIN;		//监控的事件,有数据可读
		
		/*监控标准输出描述符*/
		fds[1].fd = 1;
		fds[1].events = POLLOUT:	//要监控的事件,可以无阻塞写
	
		while(true){	
			/*开始监控描述符*/
			//不需要每次调用时都重新构建pollfd结构体，内核会在必要的时候
			//把revents清空。对于select调用，返回时会重新创建文件描述符集
			//因此每次调用都必须重新初始化。poll会把输入(evnts)输出(revents)
			//分离开
			ret = poll(fds,2,TIMEOUT*1000); //2代表描述符个数
			if(ret == -1){ // 调用失败
				//do something
				return 1;
			}

			if(ret == 0){	//超时
				//do something
				return 0;
			}
	
			/*fds[0]这个描述符,是否可无阻塞读*/
			if(fds[0].revents & POLLIN){			
				printf("stdin is readable\n");
			}

			/*fds[1]这个描述符是否可无阻塞写*/
			if(fds[1].revents & POLLOUT){
				printf("stdout is writable\n");
			}
		}

		return 0;
	}

IO多路复用select的例子:
 #include <stdio.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <stdlib.h>
 #include <netinet/in.h>
 #include <string.h>
 #include <unistd.h> //IO多路复用

 int main(int argc, char **argv){

       int fd_setsize = 2;
       fd_set read_set,ready_set; //IO多路复用的描述符集合   
       int clientfd[fd_setsize];
       int maxfd; //最大描述符      

       //////初始化
       int listenfd = open_listenfd();
       FD_ZERO(&read_set); //清空该集合
       FD_SET(STDIN_FILENO,&read_set);  //标准输入放入监控集合
       FD_SET(listenfd,&read_set);  //套接字描述符放入监控集合
       maxfd = listenfd;
       int n; 
       for(n=0; n<fd_setsize; n++){ 
          clientfd[n] = -1; 
       } 
        
       ///////轮询select 
       while(1){ //这种多路复用的方式，可以让一个进程处理多个IO，和java中的nio一样 
         
         ready_set = read_set;  //select返回后这个集合里面就是可以读的描述符 
         select(maxfd+1,&ready_set,NULL,NULL,NULL); //select每次都会修改第二个参数的执指向         
 
         //////////////////////接收客户端 add_client 
         if(FD_ISSET(listenfd,&ready_set)){ 
           struct sockaddr_in clientaddr;  //客户端套接字地址 
           int addrlen;                    //套接字地址的字节个数 
           int connfd = accept(listenfd,(struct sockaddr*)&clientaddr,&addrlen); 
           //将已经建立连接的套接字描述符放入集合 
           int i; 
           for(i = 0; i<fd_setsize; i++){ 
                if(clientfd[i] < 0){  //如果池中有空位 
                  clientfd[i]=connfd; 
                  FD_SET(connfd,&read_set); 
                  //更新最大描述符 
                  if(connfd > maxfd){ 
                        maxfd = connfd; 
                  } 
         
                  break; 
                } 
                 
           }  
           //如果池中没有空位
           if(i == fd_setsize){
                printf("接收的客户端太多了,丢弃该连接:%d!\n",connfd);
                close(connfd);
           }

         }
    
         /////////////////处理客户端的可读信息
         int j;
         for(j=0; j<fd_setsize; j++){
            int connfd = clientfd[j];
            if((connfd>0) && FD_ISSET(connfd,&ready_set)){ //集合中该描述符是否准备好   
                char c[1024]; 
                int count = read(connfd,c,1023); 
                if(count == 0){ //EOF 文件结尾 
                        close(connfd); //关闭描述符 
                        FD_CLR(connfd,&read_set); //清除读集合 
                        clientfd[j] = -1;  //删除在池中站得位置 
                        printf("clear connfd: %d\n",connfd); 
                }else if(count == -1){ 
                         printf("read connfd: %d error!",connfd); 
                }else{ 
                        c[count] = '\0'; 
                        printf("server received connfd[%d] data:%s\n",connfd,c); 
                } 
            } 
         } 
       } 
 } 

 int open_listenfd(){
        //创建套接字描述符
        int listenfd = socket(AF_INET,SOCK_STREAM,0);
        //指定特定ip地址
        struct in_addr inaddr;
        inaddr.s_addr = htonl(INADDR_ANY); //主机字节顺序转网络字节顺序，这台主机所有ip地址       
        //服务器socket地址
        struct sockaddr_in serveraddr;
        serveraddr.sin_family = AF_INET;
        serveraddr.sin_port = htons(8001);    //主机字节顺序到网络字节顺序转换
        serveraddr.sin_addr.s_addr = inaddr.s_addr;
        //listenfd描述符和服务端套接字地址绑定
        int bi = bind(listenfd,(struct sockaddr*)&serveraddr,sizeof(serveraddr));
        if(bi < 0){
                printf("绑定失败！\n");
                return -1;
        }
        //开始监听
        int li = listen(listenfd,1024);
        if(li < 0){
                printf("监听失败");
                return -1;
        }

        return listenfd;
}

#IO多路复用实现telnet程序
  #include <stdio.h>
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <stdlib.h>
  #include <netinet/in.h>
  #include <string.h>
  #include <poll.h>
  #include <unistd.h>
  #include <fcntl.h>

  int main(int argc,char *argv[]){
	//校验输入参数
	if(argc < 3){
		printf("errored arguments\n");
	}
	
	char *ip = argv[1];
	int port = atoi(argv[2]);
	int socketfd = socket(AF_INET,SOCK_STREAM,0);
	//- int flag = fcntl(socketfd,F_SETFL,O_NONBLOCK); //将文件设置为非阻塞方式	

	struct in_addr inaddr;
	int ret = inet_aton(ip,&inaddr); //ip地址
	if(ret == -1){
		perror("inet_aton");	
		return 2;
	}

	struct sockaddr_in serveraddr;	
	serveraddr.sin_family=AF_INET;
	serveraddr.sin_port = htons(port);
	serveraddr.sin_addr = inaddr;
	
	//int connect(int sockfd,struct sockaddr *serv_ddr,int addrlen)
	ret = connect(socketfd,(struct sockaddr *)&serveraddr,sizeof(serveraddr));
	//- 如果将socketfd设置为了非阻塞方式,并且链接没准备好
	//- 那么connect的返回值会是-1
	if(ret == -1){
		//- 如果socketfd为非阻塞方式并且打印Operation now in progress
		//- 那么说明连接正在进行，还没准备好
		//- 具体返回-1的原因可根据其他方式判断
		perror("connect"); 
		return 1;
	}

	int buffer=1;
	char buf[buffer];
	int len;

	//IO多路复用	
	struct pollfd fds[2];
	fds[0].fd = STDIN_FILENO;
	fds[0].events = POLLIN;
	fds[1].fd = socketfd;
	fds[1].events=POLLIN;

	while(1){
		int ret = poll(fds,2,5000); //超时时间5秒
		if(ret == -1){
			perror("poll");
			return 1;
		}
		
		//读标准输入数据
		if(fds[0].revents & POLLIN){
			len = read(0,buf,buffer);
			if(len < 0){
				perror("read(stdin)");
			}

			write(socketfd,buf,len);
		}

		//读socket数据
		if(fds[1].revents & POLLIN){
			//- 走到这里说明fd数据已经准备好,可以读
			//- 1.如果是fd是阻塞方式,那么将准备好的数据读完后再读一次则该方法会阻塞
			//- 2.如果fd是非阻塞方式,准备好的数据读完后再读一次则该方法不会阻塞
			len = read(socketfd,buf,buffer);
			if(len < 0){
				perror("read(socketfd)");
				break;
			}
			if(len == 0){
				break;
			}
			//向标准输出写数据	
			write(1,buf,len);
		}
	}
 }      

#对mmap的理解
 三个空间：
	用户空间
	内核空间
	磁盘空间
   正常情况我们读写一个文件先用open打开该文件，然后调用read,
 当A进程第一调用read方法时,内核会触发缺页处理,将文件从磁盘中
 按物理内存page大小映射到内核。如果我们read只一个字节,那么read函数
 会将一个字节从内核的pagecache中复制到进程A空间。这个时候如果进程B
 也是第一次读该文件,那么会和进程A做同样的操作,这时内核就会有两份该
 文件的cache.
   mmap的的方式是将内核的pagecache映射给用户进程，让用户进程直接对
 cache部分可见,这样就省掉了read/write在cache和进程的内存相互复制数据。
 也就是说mmap的方式仍然用到了OS的cache机制。这种方式在两个进程打开同
 一个文件的时候，内核仍然会为每个进程各缓存一份数据.
   mmap的共享存储映射,当用mmap加上MAP_SHARED配置来映射一个fd时,多个
 进程会共享同一份内核cache,这种方式可以轻松解决进程间通信,因为当不同
 进程调用mmap来映射相同fd时,返回的地址指向的是同一个内核地址.
   
 总结：
	mmap不过是让进程对内核cache部分直接可见,至于cache如何跟磁盘沟通就是
   操作系统的问题了。如果不用这块映射了可以用munmap函数,至于什么时候写
   磁盘,还是OS管。但可以调用msync函数将这个映射强制写入到磁盘。
   
#对open文件时的O_DIRECT的理解
   和mmap的方式不同,这种方式是直接抛弃OS的cache,也就是说在read/write时是
 直接操作磁盘,在read/write时需要是文件系统逻辑块大小的倍数,比如4k.
   ps:数据库实现应该用的是这个。

#查看程序都依赖于那些库(mac上用otool -L)
 $ldd ./sbin/nginx
	linux-vdso.so.1 =>  (0x00007ffffddff000)
	libpthread.so.0 => /lib64/libpthread.so.0 (0x00007f1a40ea4000)
	libcrypt.so.1 => /lib64/libcrypt.so.1 (0x00007f1a40c6d000)
	libpcre.so.1 => /usr/local/lib/libpcre.so.1 (0x00007f1a40a50000)
	libz.so.1 => /lib64/libz.so.1 (0x00007f1a4083a000)
	libc.so.6 => /lib64/libc.so.6 (0x00007f1a404a7000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f1a410c7000)
	libfreebl3.so => /lib64/libfreebl3.so (0x00007f1a40244000)
	libdl.so.2 => /lib64/libdl.so.2 (0x00007f1a40040000)
 以上是nginx在linux下依赖的库。
 =>左边是该程序需要连接的共享库.so名称,右边是在共享库文件中的具体位置。
 默认情况下,/etc/ld.so.conf文件中包含有默认的共享库搜索路径。
 
 注意:如果使用ldd命令时没有找到对应的共享库文件和位置:
	1.共享库没有安装在该系统中。
    2.共享库保存在/etc/ld.so.conf 文件列出的搜索路径之外的位置。
	比如linux系统下/etc/ld.so.conf.d/usr-local-lib.conf 文件中包含了/usr/local/lib
    所有ldd命令会从这里找,如果有些程序把自己的共享库放到了/usr/local/bin下,那么ldd
    就找不到了,需要修改/etc/ld.so.conf文件,然后运行ldconfig,这个命令用来刷新系统的
    共享库缓存即/etc/ld.so.cache文件。
  


