C语言的几种基本数据类型
 char 字符型，一个字节
 int 整形，通常反映所用机器中整数的最自然长度，至少16位
 float 当精度浮点
 double 双精度浮点
 
限定符
 short
 long
 signed
 unsigned

'\000' 用八进制表示一个字符 如'\013'
'\xhh' 用十六进制表示一个字符 如'\xb'

按位运算符
 &  按位与
 |  按位或
 ^  按位异或
 << 左移
 >> 右移
 ~  按位求反

C语言没有指定同一运算符的计算顺序
 例如x = f() + g(); 两个函数的计算顺序依赖于具体的编译器
C语言也没有指定函数参数的求职顺序
 printf("%d %d\n",++n,power(2,n)); 不确定++n先执行还是pwoer()先执行
a[i] = i++; 存在同样的问题

函数隐式声明
 如果函数没有原型声明，那么函数会在第一次出现的地方被隐式声明。
 被声明的函数返回值被假定为int型，但不对参数做类型假设。

函数的声明和定义必须一致，如果声明和定义在一个文件，则编译器会检查到该错误。
如果不在同一个文件，则无法检测到，这件会导致声明是int，定义且是其他类型(如double).
所以函数的声明和定义最好在一个文件中。

函数声明的一个例子
   int sum;
   //cc 这函数第一次出现，所以隐式声明为 int cc();
   //不对参数做假设.所以输入什么参数都可以.
   //注意：int cc(); int cc(void); 这两种声明是不一样的，
   //int cc()会把后边出现的第一个int cc(...){}视为定义
   //int cc(void) 只会把 int cc(){} 视为定义
   sum = cc("2.4");

   1) int cc(char a[]){}
   //如果1) 随后首先出现，那么1) 将被视为函数定义

   2) int cc(char a[], char b[]){}
   //如果2) 随后首先出现，那么2) 将被视为函数定义
 
   注意：1)和2)不可同时出现，因为名字相同，所以视为重复定义

   3) double cc(char a[] , char b[]){} 
   //如果3) 随后首先出现,那么3) 被视为重复声明, 并不会把这个函数看成一个定义。
   //因为前面隐式声明的类型是int,而这里是一个double
   //类似这样：int cc(); double cc();

   注意：函数声明时按照名字来确定是否已经声明；按照声明的类型和名字
         确定是否定义了函数。C语言中不会存在同名的函数。

指针和指针变量
 #include <stdio.h>
 main(){
	int  x=2;
	int* y = &x; //y是一个整型指针(地址)变量,&x是一个整型指针(地址) *y是y这个地址所指向的内容，是个整型.

	printf("%d\n",y);     //表示地址
	printf("%d\n",&x);    //表示地址
	printf("%d\n",&(*y)); //表示*y这个整型的地址

	printf("%d\n",*y);    //内存地址指向的内容
	printf("%d\n",*(&x)); //内存地址指向的内容
 } 

C中变量作用域
 在函数外的是全局变量，相同的全局变量名在整个程序中只能出现一次，
 不管这个程序是在一个文件中，还是分散在多个文件中的。
 
 在函数内的是局部变量，函数内的和函数外的相同名字的变量不会冲突。
 如果函数内要访问外部变量，如果在同一个文件内，且函数的位置在外部
 变量的后面，则可以访问，否则需要用extern进行声明。

 static修饰符可以将变量的访问范围锁定在文件内或函数内，并且该变量
 一直占用空间。
 如果变量 static int sp = 0;在某个文件内,则其他任何文件都无法访问
 该变量;如果在函数内,和其他变量的区别是,函数结束后该变量不释放空间
 
宏定义
 #define 名字 替换文本
 宏定义只是做简单的文本替换：
  #define max(A,B) A * B
  使用宏max看起来很像是函数调用,但宏调用直接将替换文本插入到代码中。
  形式参数的每次出现都将被替换成对应的实际参数。因此，语句：
	x = max(a+b,c+d);
  将被替换为：
	x = a+b*c+d;
 在替换文本中，如果参数名以#作为前缀,则参数将被替换成加双引号的字符串
 例如语句：
 	#define print(expr) printf( #expr "=%g\n",expr)
 使用语句
	print(x/y); 
 调用时将被替换为：
	printf( "x/y" "=%g\n",x/y);

 使用语句
	print("x/y");
 调用时将被替换为：
	printf( \""x/y"\" "=%g\n",\"x/y\");
 
 ##运算符用于连接两个实际的参数，如：
	#define aa(a,b) a  ## b
 调用语句
	aa(name,age);
 将被替换为：
	namgeage; //去掉了##前后的空格 

 条件包含
 defined(exp),如果exp已经被定义,其值是1，否则是0
 例句：
  #if !defined(HDR) //如果没有定义HDR
    #define HDR "aaa.h"
  #elif SYSTEM == SYSV //如果系统变量SYSTEM是SYSV
    #define HDR "bsd.h"
  #else
    #define HDR "default.h" 
  #endif
  #include HDR

 C语言专门定义的两个预处理命令
  #ifdef  //如果定义了
  #ifndef //如果没定义

C数组指针
 int bb[13];
 bb是一个指针，但不是指针变量；bb这个指针指向的是一个int型;
 &bb和bb的值一样，但意思不一样，&bb指向的是一个长度是13的int型的数组;
 所以，如果int占四个字节，那么 bb+1 跨4个字节; (&bb)+1 跨13*4个字节;

 int *bb[13]
 bb是一个指向指针的指针，数组里面的值bb[i]是一个指针，这个指针(bb[i])指向一个int型;

 int (*bb)[13]
 bb指向的是一个长度是13的int型的数组;
 bb+1 的地址跨度是13*4个字节;

C语言结构体
 定义结构:
	struct point{ //定义了一个叫point的结构
		int x;
		int y;
	};
 声明一个结构变量
	struct point cc; //声明了一个cc变量，这个变量是一个结构，这个结构名字是point;
 使用结构： 
	cc.x=12; //为结构成员变量赋值
	cc.y=15;

 匿名结构
	struct {int x; int y;} a={3,4},b={7},c;
 上面这条语句声明了三个变量，每个变量都是一个结构体，结构体中有两个整形的成员变量;

C结构和函数
 结构在函数传递的过程中仍是按值传递: 
	#include <stdio.h>
	struct point {
		int x;
		int y;
	};

	struct point addpoint(struct point p1){
		//结构的传递仍然是传值,所以这里的p1是传进来p1的一个副本
		//在这里对p1的任何操作，不会对外部操作产生影响
		p1.x= p1.x+1;
		p1.y= p1.y+1;
	
		return p1;
	}

	void addpoint_pointer(struct point *p1){
		//p1是一个指向结构体的指针，*p就是这个结构体
		(*p1).x = (*p1).x +1;
	        //为了方便，C语言提供了一种结构指针简写的方式,
        	//可以用 p1->x  代替 (*p1).x
		p1->y = p1->y +1;
	}
	
	//测试结构传递
	main(int argc, char* argv){
		struct point a;
		a.x=3;	
		a.y=4;
	
		addpoint(a);
        	//结构a中成员变量值不变, 保持x=3,y=4
		printf("%d %d\n",a.x, a.y);
	
		addpoint_pointer(&a);
		//结构a中成员变量改变, x=4,y=5
		printf("%d %d\n",a.x, a.y);
	}

位字段
 为了节省空间可以使用一个char或int对象中的位，来标记某个变量；
 例如：某一位是1表示存在某个变量，是0表示不存在等。
   定义一个屏蔽码集合 KEY=01  EXT=02 STATIC=04
 用一个char长度的二级制表示是这样:
   0000 0111 这就表示KEY EXT STATIC都存在

 C语言提供了另一种替代的方法，直接定义位字段
   struct flags{
   	unsigned int is_key:1;  //位字段宽度是1 可以表示 0,1
	unsigned int is_ext:3;  //为字段宽度是3 可以表示 000, 001, 011,101等
	unsigned int is_sta:6;  //位字段宽度是6 可表示 000000, 000001, 000111等
   };
   
   struct flags cc;
   cc.is_key=0;
   cc.is_ext=5; //小于2的三次方

C实现的头文件，在unix系统中一般放在 /usr/include 目录中

C文件操作
 FILE 文件结构，包括：缓冲区位置，缓冲区中当前字符的位置、文件的读写状态、
 是否出错或是否已经到达文件结尾等。
 FILE *fp; //定义一个执行FILE结构的指针fp

 打开一个文件
 	fp = fopen(char *name, char *mode);
        //name是文件名
        //mode是读("r")、写("w")、追加("a")、二进制("b")     
 关闭一个文件
 	fclose(fp);     
 从文件读一个字符
 	int getc(fp); //返回读到的字符，如果结束或出错返回EOF 
 向文件写一个字符
	int putc(c,stdout);//将字符c写入到标准输出，并返回写入的字符，如果出错返回EOF 
 如果流fp中出现错误，则函数ferror返回一个非0值
	int ferror(FILE *fp);//比如输出到磁盘时，磁盘满。
 如果文件fp到达文件尾，返回非零值
	int feof(FILE *fp);

 例子: readfile.c
 	#include <stdio.h>

	//读文件
	main(int argc ,char *argv[]){
		FILE *fp; //指向文件的指针
		void filecopy(FILE *infp,FILE *outfp);
	
		if(argc !=2){
			printf("命令错误，请输入文件名!\n");
			return 1;
		}

		fp = fopen(argv[1],"r"); //打开一个文件
		if(fp == NULL){ //如果发生错误，fopen返回NULL
			printf("文件：%s打开错误!\n",argv[1]);
			return 1;
		}

		int c;
		while((c=getc(fp)) != EOF){ //从文件fp中读一个字符
			putc(c,stdout); //向文件stdout中写入一个字符
		}
	
		fclose(fp); //关闭文件，每个操作系统对程序打开的文件个数都有限制

		return 0;
	} 
    
行输入和行输出 
 //从fp指向的文件中读取一行数据(包括换行符)
 //line 将读取的数据结尾加上'\0'放入line中
 //maxline 读取字符的个数，最多maxline-1个字符？
 //返回值  正常情况下返回line,发生错误或到文件结尾,则返回NULL
 char *fgets(char *line, int maxline, FILE *fp) 

 //将字符串line 写入到文件fp中
 //正常返回非负值，错误返回EOF
 int fputs(char *line, FILE *fp)

 函数gets和puts功能与fgets和fputs函数类似，但他们是对stdin和stdout
 进行操作。gets在读取字符串时，将删除结尾的'\n';而puts在写入时，将加
 上一个'\n'。

空间分配函数
 //分配n个字节的空间
 void *malloc(size_t n)
 使用：
 	int *a = (int *)malloc(sizeof(int));
        *a = 9;
 //分配n*size个字节的空间
 void *calloc(size_t n, size_t size)
 使用：
	int *p = (int *)calloc(3,sizeof(int));
        *p = 3;
	*(p+1) = 5;
	*(p+2) = 8;

UNIX系统接口
 任何时候对文件的输入输出都是通过文件描述符表示文件，不是通过文件名。
 操作系统在打开一个文件的时候，会返回一个小的非负整数，这个整数就是文件描述符。
 0、1、2分别代表标准输入、标准输出、标准错误输出；任何程序在运行的时候，都会
 打开这个三个文件。
 
系统接口read和wirte
  //fd 文件描述符
  //buf 存放读到的字符
  //n 指定要读多少个
  //n_read 实际读了; 0 表示已到达文件结尾，-1 发生了某种错误 
  int n_read = read(int fd, char *buf, int n);
  
  //fd 要写入的文件描述符
  //buf 要写入的字符
  //n 指定要写多少个
  //n_writen 写了多少个； 如果n和n_writen不相等，表明发生了错误
  int n_writen = write(int fd, char *buf, int n);

  例子：将输入写到输出
  	#include <syscall.h>
	main(){
		char buf[BUFSIZ];
		int n;
		//0 是标准输入的文件描述符
		while( (n=read(0, buf, BUFISIZ)) > 0 ){
			//1 是标准输出的文件描述符
			write(1, buf, n);
		}
	}

系统接口open、creat、close、unlink
 //该函数与标准库函数fopen很相似，不同的是该函数返回的是文件描述符(int类型)，
 //fopen返回的是一个文件指针(FILE *fp)
 //name 要打开的文件名
 //flags 打开方式,int类型; O_RDONLY 只读方式, O_WRONLY 只写方式, O_RDWR 读写方式
 //perms
 //fd 返回值，如果发生错误，返回-1
 int fd = open(char *name, int flags, int perms);

 //创建一个文件，若存在则覆盖
 //name 要创建的文件的名字
 //perms 创建的文件的权限,如0755
 //fd 创建的文件描述符，若创建失败则放回-1 
 int fd = creat(char *name, int perms);
 
 //断开文件描述符和已打开文件之间的关联
 //一个程序同时打开的文件数通常是20个
 close(int fd);

 //通过文件名删除文件
 //该函数和标准库中的remove对应
 unlink(char *name);

 例子：文件复制
 	#include <stdio.h>
	#include <stdlib.h>
	#include <fcntl.h>
	#define PERMS 0666 //对于所有者、所有者组和其他成员均可读写

	//系统调用 f1复制到f2
	main(int argc, char *argv[]){
		int f1,f2,n;
		char buf[BUFSIZ];

		if(argc != 3){
			printf("参数需要两个文件f1 to f2\n");
			exit(1);
		}
	
		if((f1 = open(argv[1], O_RDONLY, 0)) == -1){
			printf("不能打开文件 %s\n",argv[1]);
		}

		if((f2 = creat(argv[2], PERMS)) == -1){
			printf("不能创建文件 %s, mode %03o\n",argv[2],PERMS);
		}

		while( (n=read(f1,buf,BUFSIZ)) >0 ){
			if( write(f2,buf,n) != n){
				printf("写文件错误 %s\n", argv[2]);
			}
		}
	
		return 0;
	}
 
 随机访问文件
  //fd 文件描述符
  //offset 要设置的文件描述符fd的当前位置
  //origin 0 offset基于文件开始位置; 1 offset基于文件当前位置; 2 offset基于文件结束位置
  //返回值 表示文件的新位置，如果错误返回-1
  long lseek(int fd, long offset, int origin);

标准输入stdin是有缓冲区的，比如标准函数 getc(stdin);
 例如程序: 
	int c = getc(stdin);
	c = getc(stdin);
 第一次访问的时候，因为还没有缓存区，所以会先创建缓存区，再调用系统函数read填充次缓冲区，
 这时会等待用户输入数据，比如输入为"abcdef",则会返回第一个字符'a'。
 第二次访问的时候，因为缓冲区里面已经有数据了，所以会从缓冲区中取出第二字符'b'。
 当缓冲区中的数据被全部取出后，如果再次调用函数getc(stdin),会再次要求用户输入数据。


----------------CSAPP----------------
P ^ T = ~P //P异或True结果是非P

无符号数的编码
 假设一个整数用w位表示，则可以写成[x_(w-1),x_(w-2),...,x_(0)]  //_(w-1)是x的下标,
 B2U_w(Binary to Unsiged)二进制到无符号数的表示法。
 例子：
	B2U_4[0110] = 0*2的3次方  + 1*2的二次方 + 1*2的一次方 + 0*2的零次方 = 6 

补码编码，有符号数的表示
 这里一个关键是把字的最高有效位解释为负权
 B2T_w(Binary to Two's-complement)二级制的有符号数表示法
 例子
	B2T_4[0010] = -0*2的3次方 + 0*2的二次方 + 1*2的一次方 + 0*2的零次方 = 2
        B2T_4[1010] = -1*2的3次方 + 0*2的二次方 + 1*2的一次方 + 0*2的零次方 = -8+2 = -6
 有符号的表示法就是最高位加上一个负号

强制类型转换的结果保持底层的位值不变，只是改变了解释这些位的方式
 假设int是用8位表示
 int v = 1000 0001 = -128 + 1 = -127  //二进制表示，容易说明
 unsigned uv = (unsigend)v;     //位模式不变，解释发生改变,转换后 uv = 128 + 1 = 129;

从补码到无符号数的转换T2U_w,相当于把负号变成了2的w次方;原来的十进制值加上2的w次方。
 例如:假设int是8位
     int v  =  -123;
     那么转换成无符号uv就是: 2的8次方+(-123) = 133;
从无符号数到补码的转换U2T_w
 对于大于等于2的w-1次方的数，都会转换成负数；
 如果要转换的无符号数大于等于2的w-1次方，那么相当于当前数值减去2的w次方
 例如：假设int是8为
    unsigned int uv = 133;
    int v = (int)uv; //有符号的v = 133 - 2的八次方 = -123

当执行一个运算是，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会
隐式地将有符号参数强制类型转换为无符号数。
  例如：-1 < 0U; 会返回0(false)

看一个类型转换的例子
  //占用两个字节16位，因为是负数，所以坐高为是1 
  short sx = -12345; 
  //sx会首先扩大长度,变成32位,执行符号扩展,所以多出的16位全是1,然后转成无符号的
  unsigned uy = sx;  /*4294954951*/

C语言中对于任意整数值x,有 -x = ~x +1;
 例子：
	int x = 8;
	-x = ~x + 1 = -8;

直接补码乘法，以下的二进制我们都用的是补码，切符号位用圆括号括起来。
 例子：
	-3 = (1) 1 0 1  //符号位(1)
	 7 = (0) 1 1 1  //符号位(0)
 做乘法
	         	      (1)     1     0     1 = -3
			*     (0)     1     1     1 = 7
    ---------------------------------------------------------------------------------------------------
		              (1)     1     0     1
		       (1)     1      0     1  
       	        (1)     1      0      1     
	+ 0     (0)    (0)    (0)                       //这里第一个0没有带括号，因为-0 * -1 = 0  
    ---------------------------------------------------------------------------------------------------
          1      1      0      1      0     1      1    //在相加的时候，关键是把(1)当成负1 
        -1*64 + 1*32 + 0*16 + 1*8  + 0*4 + 1*2  + 1*1 = -21 

直接补码加法和乘法类似
  例子：
	-3 = (1) 1 0 1  //符号位(1)
	 7 = (0) 1 1 1  //符号位(0)
  做加法
	      (1)     1     0     1
          +   (0)     1     1     1 
      ------------------------------------------------------------------------
               0      1     0     0
             -0*8 +  1*4 + 0*2 + 0*1 = 4

执行算数右移舍入的问题
  正常情况下右移k位表示除以2的k次幂函，
  对于正数来说会向接近零的方向舍入，例如：
	7 >> 1 = 3
  对于负数来说会向远离零的方向舍入，例如：
 	-7 >> 1 = -4
  
  对某个数加上一个偏移量，会改变舍入的方向
  偏移量为2的k-1次幂
  假设：k=1 2的k-1次幂是1
  对于正数，则会向者远离零的方向舍入，例如：
 	7 + 1 >> 1 = 4
  对于负数，则会向着接近零的方向舍入，例如：
	-7 + 1 >> 1 = -3

C语言编译器gcc
 gcc -O1 -S code.c
 -O1 告诉编译器用一级优化
 -O2 二级优化
 -S  获取C语言编译器产生的汇编代码(.s)
 -c  汇编该代码，即产生一个.o的文件
 -o  指定输出文件名，默认是a.out
 -m32 32位编译
 -m64 64位编译

反汇编器objdump可以将目标代码,反汇编成汇编格式的代码
 objdump -d dest.o

CPU八个常用32位寄存器
 EAX : extend accumulator   累加寄存器
 ECX : extend counter  计数寄存器
 EDX : extend data 数据寄存器
 EBX : extend base 基址寄存器
 ESP ：extend stack pointer 栈指针寄存器
 EBP : extend base pointer 基址指针寄存器
 ESI ：extend source index 源变址寄存器
 EDI ：extend destination index 目的变址寄存器

条件码寄存器
 CF : carry flag 进位标志位。最近的操作使最高位产生了进位。可以用来检测无符号操作数的溢出。
 ZF : zero flag 零标志位。最近的操作得出的结果为0.
 SF ：sign flag 符号标志位。 最近的操作得到的结果为负数。
 OF ：overflow flag 溢出标志。 最近的操作导致一个补码溢出--正溢出或负溢出。
 
补码加法正溢出
 当整数x+y的和大于该整所能表示的最大正数时，产生正溢出

补码加法负溢出
 当整数x+y的和小于该整数所能表示的最小负数时，产生负溢出
 
栈针的结构
                     栈底
		|     .       |
		|     .	      |  
		|     .	      |                 较早的帧
		|             |
                |	      |  
  old %ebp  --> |_____________| ______________________________________________
		|     .	      |
		|     .       |
		|     .       |
		|-------------|
		|   参数n     |                调用者的帧
		|-------------|
                |     .       |
		|-------------|         
		|   参数1     |
		|-------------|
		|  返回地址   |--->pc要用到的 
		|_____________|  ___________________________________________
 帧指针%ebp --->| 老帧指针值  |
		| old %ebp    |
		|-------------|
		|             |
                | 被保存的    |
		| 寄存器、    |
		| 本地变量、  |
		| 临时变量等  |                当前帧
		|             |
		|-------------|
		|             |
		| 参数构造区域|
		|             |
 栈指针%esp --->| 	      |  _____________________________________________

过程调用和返回指令格式
	call Label      过程调用	
        call *Operand   过程调用
        leave           为返回准备栈
        ret             从过程调用中返回
 call指令得效果是将返回地址入栈，并跳转到被调用过程的起始处(更改pc值)。
 leave指令的效果是将%esp设置为，当前%ebp的上一个地址，即返回地址.效果如下：
    movl %ebp, %esp  //将当前帧地址设置为栈顶,此时栈顶存的是上一个方法的，帧的开始位置(old %ebp)。
    popl %ebp        //将 %ebp 还原为 old %ebp,%esp指向返回地址(调用者调用call指令的下一个地址)。
 ret指令的效果是将栈顶的返回地址，放入pc中。
 
 GCC产生的代码有时候会使用leave指令来释放栈帧，有时会用一个或两个popl指令。两种方法都可行。
 这两种方法的作用都是将%esp指向返回地址，然后ret指令就可以引用到栈顶得返回地址。
  
寄存器使用惯例
 %eax、%edx、%ecx //需要调用者保存的寄存器。在调用其他方法时，需要把这三个寄存器的值保存起来。
 %ebx、%esi、%edi //需要被调用这保存。如果要使用，则需将其保存。返回前需恢复它们。 	

GCC方法编译后有三部分组成
 1.建立部分：
   pushl  %ebp        //保存老的%ebp,此时栈顶指向保存old %ebp的地址
   movl   %esp, %ebp  //将此时的栈顶地址，设置为当前方法的帧指针
   pushl  %ebx        //保存 "调用者保存的寄存器"的值，如果下面有用到才会保存
 2.主体部分：
   addl   %ebx, %eax
 3.结束部分：
   leave      //为返回准备栈
   ret        //返回

数据对齐  //可以提高效率，可以用移位等操作代替乘法等擦做
 linux沿用的对齐策略是,2字节数据类型的地址必须是2的倍数，也就是地址的最低位必须是0。1010
 较大数据(int、int*、float、double)的地址必须是4的位数，地址最低方位必须是0。1100
 一个字节的数据就按1的倍数。
  例子：
	struct S1{
		int i;
		char c;
		int j;
	}
  如果不用对齐，编译器用最小9字节分配，如下图：
 	偏移 0	  4 5    9
             -------------
        内容 | i  |c| j  |
             --------------
  按4字节对齐，会分配12字节，如下图：
	偏移 0	  4    8    12 
             ----------------
        内容 | i  |c   | j  |
             ----------------
  例子2：
	struct S1{       //起始地址
		int i;   //0
		int j;   //4
		char c1; //8
		char c2; //9
		char c3; //10
	}//分配12个字节，因为char的地址按1的倍数对齐就可以，这个结构换可以在最后放一个char类型。

        struct S2{        //起始地址
		int i;    //0
		char c1;  //4
		int j;    //8 int地址要按4的倍数对齐，所以前一个c1浪费了三个字节
		char c2;  //12
		char c3;  //13
	}//分配16个字节,整个结构是4字节对齐.
	 //以上结构的对齐在32位和64位是一样的.
         //32位编译器会按最大4字节来对齐结构.
	 //64为编译器会按最大的数据类型来对齐结构.

  所以合理安排结构体成员的顺序，可以节省空间(编译器可能会做这方面的优化)。
  
函数指针的值是该函数机器代码表示中第一条指令的地址,例如：
	int fun(int x,int *p);
	int (*fp)(int,int *); //这是一个函数指针
        fp = fun;  //这个函数的第一个指令地址赋值给这个变量
        fp = fp+1; //fun函数的第二个指令地址

64位过程
 没有帧指针；作为替代，对栈位置的引用相对于栈指针。
 大多数函数在调用开始时分配所有需要的整个栈存储，并保存栈指针指向固定位置。

64为参数传递
 最多可以有6个整型(整数和指针)参数可以通过寄存器进行传递。寄存器按指定的顺序指定。
 如图：
	-----------------------------------------------------|
	操作数大小 |               参数数量                  |
                   |   1      2	     3	    4	  5   	 6   |
	-----------------------------------------------------|
	    64     | %rdi | %rsi | %rdx | %rcx | %r8  | %r9  |
        -----------------------------------------------------|
            32     | %edi | %esi | %edx | %ecx | %r8d | %r9d |
        -----------------------------------------------------|
	    16     | %di  | %si  |  %dx | %cx  | %r8w | %r9w |
	-----------------------------------------------------|
             8     | %dil | %sil | %dl  | %cl  | %r8b | %r9b |
        -----------------------------------------------------|
 在16个通用目的寄存器中，6个用来传参数，6个(%rbx,%rbp,%r12~%r15)是被调用这保存，
 1个(%rax)保存函数的返回值,一个(%rsp)作为栈指针，剩下两个(%r10,%r11)调用者保存。

x86-64 ABI指明程序可以使用当前栈之外128字节的范围(即低于当前栈指针的值).

x86-64对齐要求
 对于任何需要K字节的标量数据类型，它的起始地址必须是K的倍数。

连接器如何解析多重定义的全局符号
 强符号：函数和以初始化的全局变量
 弱符号：未初始化的全局变量
 
 1.不允许有多个相同的强符号
 2.如果有一个强符号和多个弱符号，那么选择强符号
 3.如果有多个相同弱符号，那么从这个弱符号中任意选择一个

与静态库连接
 当连接器构造一个输出的可执行文件时，它只拷贝静态库(.a结尾)里被应用程序引用的目标模块
 (静态库和可重定位目标文件*.o是不一样的，用目标文件的时候是全部拷贝)

 使用方法：
    gcc main.c /usr/bin/libc.a
 C编译器驱动程序总是传送静态函数库libc.a给连接器，所以对libc.a的引用是默认的
 
 libc.a静态库包含printf.o模块，以及printf.o调用的其它的模块，stdio.h头文件中，
 有对printf.o模块中printf函数的原型声明

重定位条目
 typedef struct{
	int offset; //要修改的引用地址的偏移量
	int symbol; //引用的符号
	type;       //该引用的类型
 }Elf32_Rel;

A)重定位PC相对引用
 如果type=R_386_PC32
 用32位编译器(main.o 中调用 swap.o中的swap方法)
    main.o 中main函数所在节的地址 400480
    swap.o 中swap函数所在节的地址 4004a0
 那么对于这样一条指令：	
        11:e8 fc ff ff ff     call   12 <main+0x12> //此时偏移量是0x12，说明这个地址是需要修改的
        16:83 c4 04           add    $0x4,%esp
 连接器最终会将修改e8后面的地址，修改过程像这样：
   将call指令所在的.text节的地址 +偏移量offset(0x12)，设该值为refaddr
   最后将offset指定的偏移地址位置的值，修改为:   
   swap符号在所在节的地址ADDR(r.symbol) - refaddr + 当前引用值(fc ff ff ff)
   结果:                0x4004a0 - (0x400480+0x12) + (-4) = 10 
   也就是链接后swap函数地址是，紧跟这个call指令的地址+10
 
 64位编译器和32稍有差别，用上面同样的程序举例
 编译出的指令是这样的:
   6:e8 00 00 00 00       callq  b <main+0xb> //直接指向了call的下一条指令,e8后面全是零
   b:31 c0                xor    %eax,%eax
 连接器用同样的算法修改e8后面的地址
   4004a0(swap函数地址) - (0x400480+0xb) + (0) = 15
 注意：
    用64位编译后的代码，对offset的解释就有点蹩脚。
    offset原定义是需要被修改的引用的节偏移，也就是说需要被修改的起始地址的值

 函数引用解析的过程：
  比如当前程序引用了一个外部的swap函数(假设所有重定位目标集合E已经完成)
  1.连接器在查看当前符号表的时候(已经放在一个未解析的符号集合U中)，看到swap这个符号是一个对外部的引用。
  2.去.rel.text这个表中找swap这个符号。迭代所有目标文件的符号表(已经放在一个已定义符号集合D中),获取swap符号的地址。
  3.存在这个符号，根据.rel.text表中这个符号的相关条目信息，修改当前程序中对swap符号的引用为swap的地址。
  链接的关键是通过.rel.text表，找到swap这个符号的绝对地址。
  

符号表.symtab用来存放一个目标文件中定义和引用的函数和全局变量的信息,只记录这个符号的定义出现的位置。
如果是一个外部引用，就需要用到.rel.text(引用外部函数)或.rel.data(全局变量)表，这个表记录了当前引用
的偏移量(offset),引用的符号symbol,引用类型type。

动态链接共享库
 共享库不会复制到可执行目标文件，而是在第一次加载后固定一个位置，此后所有用到共享库中数据的可执行文件，
 都会被动态链接器链接到特定位置。
 
 Unix通常用.so(dynamic object)后缀表示,window用dll(动态链接库)
 unix> gcc -shared -fPIC -o shardlib.so add.c swap.c  //创建共享库
 unix> gcc main.c ./shardlib.so //创建一个可以在加载时动态链接的可执行文件
 
 从应用程序中加载和链接共享库

IO发生时涉及的对象和步骤
 针对一个network IO(read操作)，涉及两个系统对象，一是调用此IO的进程或线程，
 另一个是系统内核。系统内核执行read操作时，会经历两个阶段：
   1.等待数据准备
   2.将数据从内核拷贝到进程中
 IO Model的区别就体现在这两个阶段的不同情况

 执行阶段1时，让用户程序等待返回和直接返回，体现block和non block,
 不管是block还是non block,第二阶段总是阻塞的。

 如果在read的时候,1、2都不阻塞，直接返回，等数据拷贝到进程中后通过通知或回调等方式
 通知应用程序，这种是异步IO(AIO)
 
为当前进程设置信号处理函数
  signal(signal,function) //如果进程收到一个signal信号，就异步调用function函数
  signal(signal,SIG_IGL)  //忽略类型为signal的信号
  signal(signal,SIG_DFL)  //恢复类型为signal的信号的默认行为
  注意：SIGSTOP和SIGKILL两个信号的默认行为，不会通过上面三种方式被修改
给自己发送信号,进程可以通过调用alarm函数向它自己发送SIGALRM信号
  unsiged int alarm(unsigned int secends);
  返回值：前一次闹钟剩余的秒数，如果以前没有设置则返回0; ?前一次的设置是否还有效。
  secends: 多长时间后发送信号.

发送信号
 内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。
接收信号
 当前进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。

外壳为每个作业(job)创建一个独立的进程组
 且每个作业的进程号pid就是它所属的进程组号gpid。
 外壳用:
	execve(const char *filename, const char *argv[], const char *envp[])
 来调用程序，execve加载了filename之后，调用启动代码。启动代码会将控制传递给新程序的
 主函数：
 	int main(int argc,char *argv[],char *envp[])

子进程回收
  int waitpid(int pid, int *status, int options);
  //等待某个子进程结束，成功返回后会将这个已终止的子进程从系统中清除
  //如果主进程没有子进程，返回-1，并且设置errno为ECHILD.如果waitpid被一个信号中断，
  //那么返回-1，并设置errno为EINTR.
  知识点：
    系统函数read,可能就是创建一个子进程去准备数据，然后用waitpid阻塞主进程。这个时候
   如果主进程收到一个中断信号，那么waitpid就会提前返回-1，并且errno为EINTR。
   但是子进程并没有将数据准备好，所以就可能会导致read提前返回。对于这种情况不同的系统
   处理的方式不一样，linux会再次调用read函数，确保可以返回正确的数据，在特定的Solaris系统中
   会直接返回一个错误。

用SIGCHLD信号回收子进程，这样子进程运行的时候，主进程也可以做其它的事
  例子：
    int main(){
	signal(SIGCHLD,handler);//为主进程绑定一个信号处理函数
       
        int pid = fork();
	if(pid == 0){ //子进程
		//TODO something
		exit(0);
		//当该子进程终止的时候，会向主进程发一个SIGCHLD信号，然后handler函数运行。
	}
        
        read();//读一些数据  这个过程可能被信号中断，不同系统有不同处理
        while(1){
	   //do something 这个过程可能被信号中断
	}
       
    }
    //回收子进程的函数,这个函数会在主进程中并行的执行
    void handler(int singnal){
	int status;
	int pid;
        
        //在这个信号处理函数中，waitpid会被一个信号中断吗？
        //感觉不会，因为这已经是主进程在处理信号了，如果有相同的信号它不会接收，
        //不同的信号也不应对这个产生影响.
        //主进程会并行的处理不同的信号.
        while(waitpid(-1,&status,0) > 0){ //尽可能多的回收子进程
            //这样可以避免多个子进程同时终止时，发生信号丢失的情况 
        }
        
        //waitpid返回-1代表发生错误终止，同时如果errno等于ECHILD代表是因为没有子进程了
        //如果不是ECHILD说明是其他错误. 
	if(errno != ECHILD){
		//不是正常终止的
	}         
           
	return;	
    }

非本地跳转 <setjmp.h>
  int setjmp(jmp_buf env);
  int sigsetjmp(sigjum_buf env, int savesigs); //信号
  调用一次返回两次;如果返回零那就是自身返回的，如果返回非零就是longjmp返回的。
  
  int longjmp(jmp_buf env,int returnvalue); 
  int siglongjmp(sigjmp_buf env, int returnvalue); //信号
  从不返回到自身，返回到setjmp处(或者理解成，该函数导致setjmp的第二次返回,值是returnvalue);
  注意：这两个方法好像需要在同一个进程中配合使用



