#nginx拦截错误代码,默认是off
proxy_intercept_errors on;

##安装Nginx 
1.GCC---GNU编译器集合 
  gcc是一个开源编译器集合，是用于处理各种各样的语言：C、C++、java 
  、Ada、FORTRAN，等等。 
  $yum install gcc 
2.PCRE库 
   在Nginx编译需要PCRE，因为Nginx的Rewrite模块和HTTP核心模块会使用 
   到PCRE正则表达式。需要安装两个安装包pcre和pcre-devel。第一个安装 
   包提供编译版本的库，而第二个提供开发阶段的头文件和编译项目的源代码。 
  $yum install pcre pcre-devel 
3.zlib库 
   zlib库提供了开发人员的压缩算法，在Nginx的各种模块中需要使用gzip压缩。 
  $yum install zlib zlib-devel 
4.OpenSSL 
   在Nginx中，如果服务器提供安全网页时则会用到OpenSSL库，我们需要安装库文件 
   和它的开发安装包。 
  $yum install openssl openssl-devel 
5.下载并安装Nginx 
  $ wget http://nginx.org/download/nginx-0.7.66.tar.gz 
  $ tar zxf nginx-0.7.66.tar.gz 
  $ cd ./nginx-0.7.66 
  $ ./configure 
  $ make 
  $ make install 


##启动nginx 
$ /usr/local/nginx/sbin/nginx 

##立即停止守护进程(使用TERM信号) 
$ /usr/local/nginx/sbin/nginx -s stop 

##温和地停止守护进程(使用QUIT信号) 
$ /usr/local/nginx/sbin/nginx -s quit 

##重新打开日志 
$ /usr/local/nginx/sbin/nginx -s reopen 

##重新载入配置文件 
$ /usr/local/nginx/sbin/nginx -s reload 

##配置文件默认位置 
/usr/local/nginx/conf/nginx.conf 

##指令总是以分号结尾 
worker_processes 1; 

##location 区段 
Nginx允许你定义location区段，通过指定的模式与客户端请求的URI相匹配。 
   语法: location [=|~|~* |^~ |@] /uri/{...} 
   修饰符： 
  1)[=]: URI的定位必须与指定的模式精确匹配。该模式在这里限定为一个简单的字符串， 
  不能 使用正则表达式。 
        server{ 
        server_name website.com; 
        location = /abcd { 
          #对该位置的访问： 
          a>可用http://website.com/abcd 
          b>可用http://website.com/ABCD (如果操作系统区分大小写就不可访问) 
          c>可用http://website.com/abcd?param1&param2 
          d>不可用http://website.com/abcd/ (结尾斜杠) 
          e>不可用http://website.com/abcde 
        } 
        } 
  2)[无]: URI的定位必须以指定模式开始，不可以使用正则表达式。 
         server{ 
         server_name website.com; 
         location /abcd{ 
           #对该配置的访问 
             a>可用http://website.com/abcd 
             b>可用http://website.com/ABCD   (大小写看操作系统) 
             c>可用http://website.com/abcd?param1&param2 
             d>可用http://website.com/abcd/ 
             e>可用http://website.com/abcde (只要以/abcd开头就可以) 
         } 
         } 
  3)[~]: 客户端请求的URI与指定 的正则表达式匹配必须区分大小写。 
        server{ 
        server_name website.com; 
        location ~ ^/abcd${ 
          #对该配置的访问 
            a>可用http://website.com/abcd 
            b>不可用http://website.com/ABCD  (区分大小写) 
            c>可用http://website.com/abcd?param1&param2 (不过滤查询字符串) 
            d>不可用http://website.com/abcd/ 因指定了正则表达式 
            e>不可用http://website.com/abcde 因指定了正则表达式 
        } 
        } 
  4)[~*]: 对客户端请求的URI与指定的正则表达 式匹配， 不区分大小写。 
        server{ 
        server_name website.com; 
        location  ~* ^/abcd${ 
          #对该配置的访问 
            a>可用http://website.com/abcd 
            b>可用http：//website.com/ABCD 
            c>可用http://webstie.com/abcd?param1&param2 
            d>不可用http://website.com/abcd/ 
            e>不可用http：//website.com/abcde 
        } 
        } 
  5)[^~]: 类似于无标志行为(2),URI的定位必须以指定模式开始。不同的是，如果模式匹配，那么Nginx就停止搜索其他模式 
  6)[@]: 定义命名location区段，这些区段客户端不能访问，只可以由内部产生的请求来访问，例如try_files 或 error_page                          

##Nginx在下面的顺序中搜索匹配模式 ？？？？？ 
  1.带有=修饰符的location区段， 如果指定字符串与请求的URI精确匹配，则Nginx使用该location的设置。 
  2.没有修饰符的location区段，如果指定字符串与请求的URI精确匹配，则Nginx使用该location设置。 
  3.带有^~修饰符的location， 如果指定字符串与请求的URI开始匹配，则Nginx使用该location设置。 
  4.带有~或~*修饰符的location区段， 如果正则表达式与请求的URI匹配，则Nginx使用该location设置。 
  5.没有修饰符的location区段， 如果指定字符串与URI请求开始匹配，则Nginx使用该location的设置。 
  
    例子1：请求http://website.com/document 
    server{ 
    server_name website.com; 
    location /doc{ 
    ... 
    } 
    location ~* ^/document${ 
    #会匹配该配置，因为可以精确匹配"document" 
    } 
    } 
   例子2:请求http://website.com/document 
   server{ 
   server_name website.com; 
   location /document{ 
   #会匹配该配置，因为是精确匹配并且没有修饰符的location区段(精确匹配)优先级比正则(精确匹配)高 
   } 
   location ~* ^/document${ 
   ... 
   } 
   } 
   例子3:请求http://websit.com/document 
   server{ 
   server_name website.com; 
   location ^~ /doc{ 
   #匹配该配置，^~的优先级比~或~*高 
   } 
   location ~* ^/document${ 
   ... 
   } 
   } 
  

##windows下Nginx的操作 
   start nginx    启动nginx 
   Nginx -s stop         快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。 
   Nginx -s quit         平稳关闭Nginx，保存相关信息，有安排的结束web服务。 
   Nginx -s reload       因改变了Nginx相关配置，需要重新加载配置而重载。 
   Nginx -s reopen       重新打开日志文件。 

##正则表达式的11种元字符 
  ^    行开始 
  $    行结束 
  .    任何字符 
  []   匹配指定集合内的任意字符 
  [^]  匹配不包括在指定字符集内的字符串 
  |    或 
  ()   分组 
  \    转义 
  *    0或多次 
  +    1或多次 
  ?    0或1次 
  {x}  x次 
  {x,} 至少x次 
  {x,y}x到y次 
可以用$1,$2...等来捕获子表达式 
  
##Nginx代理模块 
[proxy_pass]:指定转发到后端服务器的请求，在location中指示 
  对于TCP套接字，语法如下： 
     proxy_pass http://hostname:port; 
     proxy_pass http://unix:/path/to/file.socke; ???? 
  也可以指向upstream区段 
  例子： 
  proxy_pass http://localhost:8080; 
  proxy_pass http://127.0.0.1:8080; 
  proxy_pass http://unix:/tmp/nginx.sock; 
  proxy_pass http://192.68.0.1; 
  proxy_pass http://localhost:8080/uri/; 
  proxy_pass http://$server_name:8080; 
  使用upsteam区段 可以实现负载 
  upstream backend{ 
  server 127.0.0.1:8080; 
  server 127.0.0.1:8081; 
  } 
  location ~* \.php${ 
  proxy_pass http://backend; 
  } 
  
  location xxx{ 
  rewrite a b; 将a替换为b，例如：rewrite ^/search/(.*)$ /search.php?q=$1; 
  } 

#nginx变量
 nginx的变量在配置被加载的时候创建;在请求实际处理的时候才会赋值。
 所以无法在请求时动态的创建变量,并且使用未被定义的变量会无法启动。
 例子：
	location  /var {
		echo 	"var = $var";
	}
 由于$var未定义所以启动失败.
 
 一旦变量被创建，则整个nginx配置都可见，但并不意味着该变量值被共享，
 每个请求都有自己对这个变量赋值的副本，相互不受影响.
 例子：
	location /var {
		echo	"var = $var";
	}
    location /var2 {
		set $var "var";
		echo "var = ${var}2";
	}
 如果对其访问，则
	/var输出    var = 
	/var2输出	var = var
 
 nginx变量的生命周期存在于一个请求内，包括内部跳转,与其它无关
	location /var {
		set $var "var";
		echo_exec	/var2;
		#rewrite ^	/var2;
	} 
	location /var2 {
		echo	"var = -- $var --"
	}
 输出结果:
	var = -- var --

 以上是自定义变量，还有一些各个模块的内置变量，比如核心模块
 的$arg_xx、$args、$sent_http_xx等.
 大部分内置变量是不能修改的,有些可以,如$args,$arg_xx,该变量存放
 请求的querystring(未解码),如:
	location /args {
		echo "args=[$args]";
	}
 用url /args?a=b&c=11中11 访问则会输出:
	args=[a=b$c=11%E4%B8%AD11]
 
 像arg_xx内部变量会args从解析出对应的xx变量值,比如
	location /args {
		set		$orig_args	$args;	
		set 	$args "a=1&b=2";
		echo	"orig_args=[$orig_args]";
		echo 	"args=[$args]";
	}
 用url /args?a=3&b=4 访问该location,则输出:
	orig_args=[a=3&b=4]
	args=[a=1&b=2]

 标准ngx_map模块的map配置指令
	map $args $foo {
		default		a;
		debug		b;
	} 	
    server {
		listen 80;
		
		location /test {
			echo	"args=[$args]";
			echo	"foo=[$foo]";
		}
	}
 以上表示将$args对$foo的一个映射，但并不是将$args的值给$foo
 而是说当$args这个变量的值是debug时,$foo的值是b,否则是a.
  	 $curl	'http://localhost/test?debug'
	  --> args=[debug]
	  --> foo=[b]
 map指令在只能在server外部，执行过程大概如下描述：
  当请求过来后，ngxin去调用函数去取args参数的值，在取得过程中
  会map指令做考虑(猜测,为看源码). 

 子请求,就是不是通过客户端请求来的,但也不是内部跳转，内部跳转使用
 的变量和整个请求共享，但是子请求一般不共享变量。也有共享的如
 ngx_auth_request模块,一般都会禁用其父子共享变量。
 例子:
	location /main {
		echo			"main[$args]";
		echo_location /sub1;
		echo_location /sub2 "a=1&b=2";
	}

	location /sub1 {
		echo  "sub1[$args]";
	}
	location /sub2 {
		echo   "sub2[$args]";
	}
 访问/main?c=3,则会串行执行并输出,不管对错。
   	main[c=3]
	sub1[]
    sub2[a=1&b=3]
 同时我们也看到各个请求之前的变量相互独立。

 但不是所有的内置变量都作用于当前请求。指作用于第一次的请求,以后的
 子请求只用之前的值,比如核心模块的$request_method变量。
 例子：
	location /main {
		echo "main method=[$request_method]";
		echo_location /sub1;
	}
	location /sub1 {
		echo "sub method=[$request_method]";
	}
 用POST方式访问输出结果:
	main method=[POST]
	sub method=[POST]
 用GET方式访问输出结果:
	main method=[GET]
	sub  method=[GET]
 因为echo_location 是按GET方式请求的,所以根据结果可得知，
 $request_method变量无法获取子请求的method。为了获取子请求的method
 我们可以使用第三方ngx_echo模块提供的$echo_request_method变量。
 
 注意:以上说的所谓子请求并不是真正的发出HTTP请求,只是在nginx内部调用
  几个函数,并没有走socket之类的网络。

 Nginx中的变量有三种值:字符串、无效值、not found。
 比如$var这个变量只创建但并未赋值时,则$var就是无效的(invalid);如果请求
 中根本没有arg_xxx这个参数，则就是not found.

#Nginx指令的执行顺序
 nginx在处理用户请求的时候都是按不同阶段一次处理的。
 nginx模块提供的配置指令一般都会注册在某个处理阶段,但并非所有
 的指令都会绑定某个阶段，比如geo指令和map指令属于声明性的，不
 直接产生某种动作。
 nginx请求处理阶段有11个，执行的时候按阶段先后顺序依次处理在该
 阶段绑定的指令。11个阶段依次如下：
	post_read
 	server_rewrite
	find_config
	rewrite
	post_rewrite
	preaccess
	access
	post_access
	try_files
	content
	log

 看下面的例子：
	location /test {
		set  $a 1;
		echo $a;
	
		set  $a 2;
		echo $a;
	}
 访问 /test 输出
 	2
    2
 因为set指令绑定在rewrite阶段,echo指令绑定在content阶段
 所以会先执行完set指令后再指令echo指令。

#----------------ngx_http_geo_module------------------
 该模块用客户端的ip地址创建变量
 	geo $geo {
		default		    "a";
	
		127.0.0.1	    "b"; 
		127.0.0.1/16    "c";
		127.0.0.1/32    "d";		
 	}
 如果客户端ip地址是127.0.0.1则优先匹配最长的子网掩码,
 没写子网掩码则默认是32,并且优先于有子网掩码的。实际上
 以上的配置除啦127.0.0.1其他都没什么意义。
 所以上面例子$geo变量值是b,如果没有这个配置,则变量值为d。

 默认情况nginx从$remote_addr获取IP地址；可以让其从其他变量
 获取ip地址，比如：
	geo $arg_ip  $geo {
		default			"a";
		192.168.195.1   "b";
    }
 
  

#----------------HttpRedis2Module----------
#指令
 #redis2_connect_timeout
  和redis建立链接的超时时间,默认单位秒.
  支持单位:s(秒)、ms(毫秒)、y(年)、M(月)、w(周)、d(天)、h m 

 #redis2_send_timeout
  发送请求命令到redis的超时时间. ?非阻塞模式下如何计算的,貌似通过系统参数设置
  如：TCP_USER_TIMEOUT

 #redis2_read_timeout
  从redis接收响应的超时时间.

 #redis2_buffer_size
  从redis读取响应的缓存大小

 #redis2_next_upstream
  指定失败条件,这个条件成立后，请求转发到另一个server.
  前提是redis2_pass 后面的upstream有多个server。

#链接池
 例子：
	upstream backend{
		server 127.0.0.1:6379
		keepalive 1024; //池大小
	}
	
    server{
		location = /redis{
			redis2_pass backend;	
		}
	}




