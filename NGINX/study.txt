#nginx拦截错误代码,默认是off
proxy_intercept_errors on;

##安装Nginx 
1.GCC---GNU编译器集合 
  gcc是一个开源编译器集合，是用于处理各种各样的语言：C、C++、java 
  、Ada、FORTRAN，等等。 
  $yum install gcc 
2.PCRE库 
   在Nginx编译需要PCRE，因为Nginx的Rewrite模块和HTTP核心模块会使用 
   到PCRE正则表达式。需要安装两个安装包pcre和pcre-devel。第一个安装 
   包提供编译版本的库，而第二个提供开发阶段的头文件和编译项目的源代码。 
  $yum install pcre pcre-devel 
3.zlib库 
   zlib库提供了开发人员的压缩算法，在Nginx的各种模块中需要使用gzip压缩。 
  $yum install zlib zlib-devel 
4.OpenSSL 
   在Nginx中，如果服务器提供安全网页时则会用到OpenSSL库，我们需要安装库文件 
   和它的开发安装包。 
  $yum install openssl openssl-devel 
5.下载并安装Nginx 
  $ wget http://nginx.org/download/nginx-0.7.66.tar.gz 
  $ tar zxf nginx-0.7.66.tar.gz 
  $ cd ./nginx-0.7.66 
  $ ./configure 
  $ make 
  $ make install 


##启动nginx 
$ /usr/local/nginx/sbin/nginx 

##立即停止守护进程(使用SIGTERM信号) 
$ /usr/local/nginx/sbin/nginx -s stop 

##温和地停止守护进程(使用SIGQUIT信号) 
$ /usr/local/nginx/sbin/nginx -s quit 

##重新打开日志(使用SIGUSR1信号)
$ /usr/local/nginx/sbin/nginx -s reopen 

##重新载入配置文件(使用SIGHUP信号)
 $ /usr/local/nginx/sbin/nginx -s reload 
 $ kill -SIGHUP master_pid
 
 master接收到该信号后会,先重新加载配置文件,然后重启新的worker并
 接收新的请求,老的worker收到master的停止接收新情求的信号后,处理
 完当前的请求后退出。
 
##配置文件默认位置 
/usr/local/nginx/conf/nginx.conf 

##指令总是以分号结尾 
worker_processes 1; 

##location 区段 
Nginx允许你定义location区段，通过指定的模式与客户端请求的URI相匹配。 
   语法: location [=|~|~* |^~ |@] /uri/{...} 
   修饰符： 
  1)[=]: URI的定位必须与指定的模式精确匹配。该模式在这里限定为一个简单的字符串， 
  不能 使用正则表达式。 
        server{ 
        server_name website.com; 
        location = /abcd { 
          #对该位置的访问： 
          a>可用http://website.com/abcd 
          b>可用http://website.com/ABCD (如果操作系统区分大小写就不可访问) 
          c>可用http://website.com/abcd?param1&param2 
          d>不可用http://website.com/abcd/ (结尾斜杠) 
          e>不可用http://website.com/abcde 
        } 
        } 
  2)[无]: URI的定位必须以指定模式开始，不可以使用正则表达式。 
         server{ 
         server_name website.com; 
         location /abcd{ 
           #对该配置的访问 
             a>可用http://website.com/abcd 
             b>可用http://website.com/ABCD   (大小写看操作系统) 
             c>可用http://website.com/abcd?param1&param2 
             d>可用http://website.com/abcd/ 
             e>可用http://website.com/abcde (只要以/abcd开头就可以) 
         } 
         } 
  3)[~]: 客户端请求的URI与指定 的正则表达式匹配必须区分大小写。 
        server{ 
        server_name website.com; 
        location ~ ^/abcd${ 
          #对该配置的访问 
            a>可用http://website.com/abcd 
            b>不可用http://website.com/ABCD  (区分大小写) 
            c>可用http://website.com/abcd?param1&param2 (不过滤查询字符串) 
            d>不可用http://website.com/abcd/ 因指定了正则表达式 
            e>不可用http://website.com/abcde 因指定了正则表达式 
        } 
        } 
  4)[~*]: 对客户端请求的URI与指定的正则表达 式匹配， 不区分大小写。 
        server{ 
        server_name website.com; 
        location  ~* ^/abcd${ 
          #对该配置的访问 
            a>可用http://website.com/abcd 
            b>可用http：//website.com/ABCD 
            c>可用http://webstie.com/abcd?param1&param2 
            d>不可用http://website.com/abcd/ 
            e>不可用http：//website.com/abcde 
        } 
        } 
  5)[^~]: 类似于无标志行为(2),URI的定位必须以指定模式开始。不同的是，如果模式匹配，那么Nginx就停止搜索其他模式 
  6)[@]: 定义命名location区段，这些区段客户端不能访问，只可以由内部产生的请求来访问，例如try_files 或 error_page                          

##Nginx在下面的顺序中搜索匹配模式 ？？？？？ 
  1.带有=修饰符的location区段， 如果指定字符串与请求的URI精确匹配，则Nginx使用该location的设置。 
  2.没有修饰符的location区段，如果指定字符串与请求的URI精确匹配，则Nginx使用该location设置。 
  3.带有^~修饰符的location， 如果指定字符串与请求的URI开始匹配，则Nginx使用该location设置。 
  4.带有~或~*修饰符的location区段， 如果正则表达式与请求的URI匹配，则Nginx使用该location设置。 
  5.没有修饰符的location区段， 如果指定字符串与URI请求开始匹配，则Nginx使用该location的设置。 
  
    例子1：请求http://website.com/document 
    server{ 
    	server_name website.com; 
    	location /doc{ 
    		... 
    	} 

    	location ~* ^/document${ 
    		#会匹配该配置，因为可以精确匹配"document" 
    	} 
    } 
   例子2:请求http://website.com/document 
   server{ 
	    server_name website.com; 
	    location /document{ 
   	   	   #会匹配该配置，因为是精确匹配并且没有修饰符的location区段(精确匹配)优先级比正则(精确匹配)高 
   	    } 
   		location ~* ^/document${ 
   			... 
   		} 
   } 
   例子3:请求http://websit.com/document 
   server{ 
   		server_name website.com; 
   		location ^~ /doc{ 
   			#匹配该配置，^~的优先级比~或~*高 
   		} 
   		location ~* ^/document${ 
   			... 
   		} 
   } 
  

##windows下Nginx的操作 
   start nginx    启动nginx 
   Nginx -s stop         快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。 
   Nginx -s quit         平稳关闭Nginx，保存相关信息，有安排的结束web服务。 
   Nginx -s reload       因改变了Nginx相关配置，需要重新加载配置而重载。 
   Nginx -s reopen       重新打开日志文件。 

##正则表达式的11种元字符 
  ^    行开始 
  $    行结束 
  .    任何字符 
  []   匹配指定集合内的任意字符 
  [^]  匹配不包括在指定字符集内的字符串 
  |    或 
  ()   分组 
  \    转义 
  *    0或多次 
  +    1或多次 
  ?    0或1次 
  {x}  x次 
  {x,} 至少x次 
  {x,y}x到y次 
可以用$1,$2...等来捕获子表达式 
  
##Nginx代理模块 
[proxy_pass]:指定转发到后端服务器的请求，在location中指示 
  对于TCP套接字，语法如下： 
     proxy_pass http://hostname:port; 
     proxy_pass http://unix:/path/to/file.socke; ???? 
  也可以指向upstream区段 
  例子： 
  proxy_pass http://localhost:8080; 
  proxy_pass http://127.0.0.1:8080; 
  proxy_pass http://unix:/tmp/nginx.sock; 
  proxy_pass http://192.68.0.1; 
  proxy_pass http://localhost:8080/uri/; 
  proxy_pass http://$server_name:8080; 
  使用upsteam区段 可以实现负载 
  upstream backend{ 
  server 127.0.0.1:8080; 
  server 127.0.0.1:8081; 
  } 
  location ~* \.php${ 
  proxy_pass http://backend; 
  } 
  
  location xxx{ 
  rewrite a b; 将a替换为b，例如：rewrite ^/search/(.*)$ /search.php?q=$1; 
  } 

#nginx变量
 nginx的变量在配置被加载的时候创建;在请求实际处理的时候才会赋值。
 所以无法在请求时动态的创建变量,并且使用未被定义的变量会无法启动。
 例子：
	location  /var {
		echo 	"var = $var";
	}
 由于$var未定义所以启动失败.
 
 一旦变量被创建，则整个nginx配置都可见，但并不意味着该变量值被共享，
 每个请求都有自己对这个变量赋值的副本，相互不受影响.
 例子：
	location /var {
		echo	"var = $var";
	}
    location /var2 {
		set $var "var";
		echo "var = ${var}2";
	}
 如果对其访问，则
	/var输出    var = 
	/var2输出	var = var
 
 nginx变量的生命周期存在于一个请求内，包括内部跳转,与其它无关
	location /var {
		set $var "var";
		echo_exec	/var2;
		#rewrite ^	/var2;
	} 
	location /var2 {
		echo	"var = -- $var --"
	}
 输出结果:
	var = -- var --

 以上是自定义变量，还有一些各个模块的内置变量，比如核心模块
 的$arg_xx、$args、$sent_http_xx等.
 大部分内置变量是不能修改的,有些可以,如$args,$arg_xx,该变量存放
 请求的querystring(未解码),如:
	location /args {
		echo "args=[$args]";
	}
 用url /args?a=b&c=11中11 访问则会输出:
	args=[a=b$c=11%E4%B8%AD11]
 
 像arg_xx内部变量会args从解析出对应的xx变量值,比如
	location /args {
		set		$orig_args	$args;	
		set 	$args "a=1&b=2";
		echo	"orig_args=[$orig_args]";
		echo 	"args=[$args]";
	}
 用url /args?a=3&b=4 访问该location,则输出:
	orig_args=[a=3&b=4]
	args=[a=1&b=2]

 标准ngx_map模块的map配置指令
	map $args $foo {
		default		a;
		debug		b;
	} 	
    server {
		listen 80;
		
		location /test {
			echo	"args=[$args]";
			echo	"foo=[$foo]";
		}
	}
 以上表示将$args对$foo的一个映射，但并不是将$args的值给$foo
 而是说当$args这个变量的值是debug时,$foo的值是b,否则是a.
  	 $curl	'http://localhost/test?debug'
	  --> args=[debug]
	  --> foo=[b]
 map指令在只能在server外部，执行过程大概如下描述：
  当请求过来后，ngxin去调用函数去取args参数的值，在取得过程中
  会map指令做考虑(猜测,为看源码). 

 子请求,就是不是通过客户端请求来的不走HTTP协议的请求,但也不是内部跳转,
 内部跳转使用的变量和整个请求共享,但是子请求一般不共享变量。也有共享的如
 ngx_auth_request模块,一般都会禁用其父子共享变量。
 #--------------------------------------------------------------------
 注意:所谓的内部跳转就是强行将当前阶段退回到find-config阶段,这样就可以
      让URI重新和location块进行匹配.
 #--------------------------------------------------------------------
 例子:
	location /main {
		echo			"main[$args]";
		echo_location /sub1;
		echo_location /sub2 "a=1&b=2";
	}

	location /sub1 {
		echo  "sub1[$args]";
	}
	location /sub2 {
		echo   "sub2[$args]";
	}
 访问/main?c=3,则会串行执行并输出,不管对错。
   	main[c=3]
	sub1[]
    sub2[a=1&b=3]
 同时我们也看到各个请求之前的变量相互独立。

 但不是所有的内置变量都作用于当前请求。指作用于第一次的请求,以后的
 子请求只用之前的值,比如核心模块的$request_method变量。
 例子：
	location /main {
		echo "main method=[$request_method]";
		echo_location /sub1;
	}
	location /sub1 {
		echo "sub method=[$request_method]";
	}
 用POST方式访问输出结果:
	main method=[POST]
	sub method=[POST]
 用GET方式访问输出结果:
	main method=[GET]
	sub  method=[GET]
 因为echo_location 是按GET方式请求的,所以根据结果可得知，
 $request_method变量无法获取子请求的method。为了获取子请求的method
 我们可以使用第三方ngx_echo模块提供的$echo_request_method变量。
 
 注意:以上说的所谓子请求并不是真正的发出HTTP请求,只是在nginx内部调用
  几个函数,并没有走socket之类的网络。

 Nginx中的变量有三种值:字符串、无效值、not found。
 比如$var这个变量只创建但并未赋值时,则$var就是无效的(invalid);如果请求
 中根本没有arg_xxx这个参数，则就是not found.

#Nginx指令的执行顺序
 nginx在处理用户请求的时候都是按不同阶段一次处理的。
 nginx模块提供的配置指令一般都会注册在某个处理阶段,但并非所有
 的指令都会绑定某个阶段，比如geo指令和map指令属于声明性的，不
 直接产生某种动作。
 nginx请求处理阶段有11个，执行的时候按阶段先后顺序依次处理在该
 阶段绑定的指令。11个阶段依次如下：
	post-read 当nginx读取并解析完请求头后开始运行
 	server-rewrite
	find-config 该阶段不支持模块注册,而是由ngxin核心来完成请求与location
                配置的匹配工作,也就是说再次之前没有任何请求与location配置
 	            块相关联。所以对于运行在该阶段之前的阶段,他们的指令应该配
	            置在location块之外,否则不起作用。
	rewrite
	post-rewrite 不接受注册,如果在rewrite阶段指定了要做内部跳转,那么该阶段
		    	 就会将当前请求强制退回到find-config阶段。
	preaccess
	access 		 运行在该阶段的指令多是执行访问控制性质的任务,比如检查
		   		 用户的访问权限,检查用户的来源Ip地址是否合法等。
	post-access  不接受注册,主要用于配合access阶段实现核心模块的satisfy功能
	try-files	 不接受注册,专门用于实现try_files指令的功能
	content

MSS:最大报文段长度，表示TCP传往另一端的最大块数据的长度。
	log

 看下面的例子：
	location /test {
		set  $a 1;
		echo $a;
	
		set  $a 2;
		echo $a;
	}
 访问 /test 输出
 	2
    2
 因为set指令绑定在rewrite阶段,echo指令绑定在content阶段
 所以会先执行完set指令后再指令echo指令。













#----------------ngx_http_geo_module------------------
 该模块用客户端的ip地址创建变量
 	geo $geo {
		default		    "a";
	
		127.0.0.1	    "b"; 
		127.0.0.1/16    "c";
		127.0.0.1/32    "d";		
 	}
 如果客户端ip地址是127.0.0.1则优先匹配最长的子网掩码,
 没写子网掩码则默认是32,并且优先于有子网掩码的。实际上
 以上的配置除啦127.0.0.1其他都没什么意义。
 所以上面例子$geo变量值是b,如果没有这个配置,则变量值为d。

 默认情况nginx从$remote_addr获取IP地址；可以让其从其他变量
 获取ip地址，比如：
	geo $arg_ip  $geo {
		default			"a";
		192.168.195.1   "b";
    }



#----------------HttpRedis2Module----------
#指令
 #redis2_connect_timeout
  和redis建立链接的超时时间,默认单位秒.
  支持单位:s(秒)、ms(毫秒)、y(年)、M(月)、w(周)、d(天)、h m 

 #redis2_send_timeout
  发送请求命令到redis的超时时间. ?非阻塞模式下如何计算的,貌似通过系统参数设置
  如：TCP_USER_TIMEOUT

 #redis2_read_timeout
  从redis接收响应的超时时间.

 #redis2_buffer_size
  从redis读取响应的缓存大小

 #redis2_next_upstream
  指定失败条件,这个条件成立后，请求转发到另一个server.
  前提是redis2_pass 后面的upstream有多个server。

#链接池
 例子：
	upstream backend{
		server 127.0.0.1:6379
		keepalive 1024; //池大小
	}
	
    server{
		location = /redis{
			redis2_pass backend;	
		}
	}

#nginx中引用文件指令的当前路径
 在安装Nginx的时候有一个prefix参数,比如我本机安装时用的是:
 	--prefix=/My/work/nginx/nginx
 
 include的指令的当前路径在conf目录下,范围在server、http、location等
 区域,没什么限制.
    location /path {
        include   domains/cc.conf;  //domains目录必须在--prefix/conf/下。
    }

 content_by_lua_file指令的当前目录和conf同目录,范围location、location if
	location /path {
		content_by_lua_file	path.lua; //path.lua一定和--prefix 同目录。
	}

#指令set和set_by_lua混合使用的例子
  location /test {
		set $a	10;
		set $b	20;
		set_by_lua $c "return ngx.var.a + ngx.var.b";
		set $content "$a + $b = $c";
	
		echo $content;	
  }
 访问 /test 输出结果
	10 + 20 = 30
 从上面可以看到,属于不同模块的指令,有序的执行了。因为nginx中只有
 字符串,所以用到了lua对加数自动类型转换的特性,这样就计算出了两个
 数字的和,然后再利用nginx的”变量插值“将字符串输出。
 
 第三方模块ngx_lua的set_xx指令之所以能和ngx_rewrite模块的set指令混合使用
 ,并且指令执行顺序和配置指令的顺序相同,是不仅因为这两个指令都在rewrite阶
 段,因为它借助了第三方模块ngx_devel_kit,将自己的配置指令融合到了ngx_rewrite
 模块中。也就是说,如果第三方模块A和B的指令也在rewrite阶段,但是并没有使用
 ngx_devel_kit模块进行融合,那么不管他们的配置指令是否交叉,指令执行的时候
 一定是先执行完一个模块的指令后在执行另一个模块的指令。(具体哪个模块的指令
 向执行,一般有模块的加载顺序决定,有例外)。

#more_set_input_headers指令(属第三方ngx_headers_more模块)
 该指令总是运行在rewrite阶段的末尾,用于操纵当前请求的请求头,还可以
 在请求头不存在时自动创建。
 例子:
	location /text {
		set $value	 aaa;
		more_set_input_headers   "Head-Masf:$value";
		set $value	 bbb;
	
		echo "Head-Masf:$http_head_masf";
	}
 这个例子是在修改或创建请求头Head-Masf的值.另外$http_xxx变量在匹配请求头时
 会自动将请求头的字母转换为小写字母,同时把"-"转换为"_",所以匹配请求头Head-Masf
 需要用$http_head_masf变量.最后因为more_set_input_headers指令总在rewrite末尾
 执行,所以输出结果为 Head-Masf:bbb
 
 这个例子证明了即使运行在同一个请求处理阶段,所属不同模块的指令也可能会分开
 独立运行.
 ps:rewrite_by_lua指令也运行在rewrite的末尾阶段.

 //清理响应头
 more_clear_headers 'Content-Type';
 //设置响应头
 more_set_headers   'Content-Type: text/plain'

#标准模块ngx_access的allow和deny指令用于控制哪些Ip地址可以访问,哪些不可以
 这两个指令运行在access阶段.
 例子:
	location /test {
		allow	127.0.0.1;
		deny	all;

		echo "hello";
	}
 访问 /test 如果远端ip地址不是127.0.0.1则返回403状态.

#单个阶段同时运行多个模块的指令问题
 一般情况下,单个阶段绑定的不同模块的指令可以同时使用,但是content
 阶段则例外.大多数模块在向content阶段注册指令时,都是在当前的location
 配置块中注册content handler(内容处理程序). 值得注意的是每个location
 只能有一个content handler,因此当同时有多个模块向content阶段注册指令
 时,只会成功一个,具体哪个成功则不确定。但是同一个模块的不同指令没限制。
 例如:
	location /test {
		echo 	hello;
		content_by_lua 'ngx.say("world hello")';
		echo	world;
	}
 访问 /test 可能输出
      hello
      world
 这个例子中,echo和content_by_lua指令同属content阶段但不属同一个模块,
 因此只有一个指令可以注册成功.

 如果想看到我们预期的输出,可以使用echo_before_body等指令,例如:
	location /test {
		echo_before_body	hello;
		content_by_lua	'ngx.say("world hello")';
		echo_after_body		world;
	} 
 访问 /test 则输出
	 hello
	 world hello
	 world
 之所输出这样的结果,因为Nginx在输出响应体数据时调用"输出过滤器",这两
 条指令就在数据输出之前和之后调用。需要注意的是"输出过滤器"并不属于
 Nginx定义的11个阶段。 
	
#content阶段的静态资源服务模块
 Nginx会在该阶段安排三个静态资源服务块,当在content阶段没有注册任何指令
 的时候,也就是说在 location / {} 块中没有配置任何content阶段的指令时会
 相应的触发ngx_index、ngx_autoindex、ngx_static模块.

 ngx_index和ngx_autoindex 只会作用于URI以 / 结尾的请求,例如GET /cc/,
 如果不是以 / 结尾则把控制权交给下一个模块。而ngx_static模块值处理不以 / 结尾的请求。
 ngx_index模块主要用于在文件系统目录中自动查找指定的首页文件。
 例如:
	location /bb/ {
		root /var/www/;    //用root来指定"首页"所在的目录
		index index.htm  index.html shouye.ht; //用index指定"首页"文件名
	    #autoindex on;   //自动生成目录索引,默认off
	}
 访问 /bb/ 因为以 / 结尾所以ngx_index模块会起作用,执行顺序如下:
	在/var/www/bb/ 目录下按顺序查找index指令指定的文件名,假设第一个文件index.htm
    存在,则直接发起"内部跳转"到 /bb/index.htm 这个新的uri,然后重新匹配location。
     
    如果我们没有 location /bb/index.htm {} 这样的location,那么就会重新匹配到我们的
    location /bb/ {},这次因为不是以 / 结尾的,所以ngx_index模块不再起作用。然后交给
    content阶段的下一个模块,如果ngx_autoindex模块的autoindex 指令是on则就会自动生成
    一个当前目录的索引,然后就可以在浏览器上看到当前目录都有哪些内容。

    因为我们这里没有设置autoindex指令,所以这里下一个模块是ngx_static。 
     
    ngx_static模块会根据root指令的配置确认.../bb/index.htm文件是否存在,如果存在则
    直接输出,并附加上一些响应头信息。如果不存在则抛出404。

    ngx_static模块是content阶段默认垫底的最后一个模块,该模块才是真正把静态文件展示
    出去的功臣。

    如果遍历到最后都没有在指定的目录下找到index 配置的文件名,则交给content阶段的下一
    个模块。

 注意:在上面我们提到了,当找到指定文件后并不是直接输出,而是就发起了一个内部跳转,但是
 如果这个时候我们有这样一个locaiton：
    location /bb/index.htm {
	    echo "ccccccc";
	}		
 那么最终输出给客户端的数据是cccccc,因为location在匹配的时候用的是"贪婪"匹配,所以会先
 匹配/bb/index.htm,又因为存在content阶段的指令echo,所以不会触发静态模块结果就被截胡了。

#ngx_static模块(content阶段的垫底模块)
 看这样一个例子:
	location / {
		root  /My/work/nginx/nginx/html/ ;
	} 
 在/html/目录下有hello.html index.html两个文件,且内容同文件名.
 我们访问 /hello.html 则输出
	hello
 他的执行顺序是这样的:
	首先,因为我们的location没有配置任何运行在contenet阶段的指令,所以location的
	content handler(内容处理程序)就没有被注册,这时候处理权落到了content阶段的三
	个静态资源服务模块中。
	
	首先运行的ngx_index和ngx_autoindex模块并没有看到以 / 结尾的URI,所以直接放弃,
	接着处理权落到了ngx_static模块。该模块根据root指令的配置,确认.../html/hello.html
    文件是否存在,如果存在则将他们的内容输出,并自动设置Content-Type、Content-Length
    以及Last-Modified等响应头。
 如果上面的location下没有配置root指令,那么默认用--prefix的目录

 另外一个需要注意的是如果你的location并不是在提供静态服务,一定注意在
 location 下是不是这是了 content 阶段的指令,如果没有的话就会走静态模块。
 例如：
	location /get {
		set	$a = b;
	}
 如果访问 /get 则该请求最终会交给ngx_static模块处理,该模块会去文件系统
 上找 [--prefix目录]/get 这个文件,如果你的目录下没有get这个文件,那么就
 会抛出404错误。

#set_real_ip_from指令,ngx_realip标准模块默认未开启,--with-http_realip_module
 这个指令在第一个阶段post-read执行,该指令也注册到了preaccess阶段
 例子: 	
	set_real_ip_from 127.0.0.1;
	real_ip_header	Real-Ip;
 	location /real_ip {
		echo "from:[$remote_addr]";
	}
 本机访问/real_ip 并指定请求头Real-Ip
   $curl -H 'Real-Ip:192.18.1.1' /real_ip
 输出
	from:[192.18.1.1]
 
#rewrite指令,属ngx_rewrite模块
 语法: rewrite regex replacement [flag];

 该指令只是在做简单的URI重写,不会立即进行内部跳转,而是简单的指定有必要
 在随后的post-rewrite阶段发生内部跳转。
 例子:
 	location /foo {
		rewrite ^ /bar;
		rewrite ^ /baz;

		echo 	"aaa";
	}
	location /bar {
		echo 	"bbb";
	}
	location /baz {
		echo 	"ccc";
	}
 访问 /foo 执行完两个rewrite指令后,URI最终被修改为/baz,之后进入post-rewrite
 阶段,该阶段执行内部跳转将请求强行退回到find-config阶段,然后最终匹配到/baz
 这个location,输出结果
	ccc
 从执行顺序可以看到/foo中的 echo 指令因为在content阶段,所以根本没有机会执行

#satisfy指令,属于核心标准模块
 该指令主要用于对注册在 access 阶段的各个模块的程序进行协调。
 例子:
	location /test {
		satisfy 	all;
	
		deny 		all; //该指令注册在access阶段	
		access_by_lua 'ngx.exit(ngx.OK)'; //注册在access阶段

		echo 	"hello";
	} 
 上面的例子表示,只用在access阶段的指令都同意先下走时,才会输出 hello 字符.
 对于上面,因为deny 指令总是拒绝先下走,所以会直接返回403。
 如果将例子中的 satisfy 赋值 any 则表示只要有一个access阶段的指令同意就可以
 输出 hello字符。注意:默认satisfy的值是all。

#try_files指令,属标准核心模块
 该指令接收两个以上的参数,每个参数都是一个URI,如果指定的URI后面带有"/"则
 会直接抹掉这个斜杠。
 例子:
	root /var/www/;
	location /test {
		try_files /foo /bar/ /barz;
		echo "uri:$uri";
	}
 执行顺序是这样的,该指令会依次把前n-1个参数映射为文件系统上的对象,然后检查
 是否存在.如果遇见存在的就不在向后检查,会把当前URI改写为对应的URI,比如访问
 /test 时如果/var/www/foo这个文件存在,那么URI就会被改写为/foo,然后走向下一
 个阶段。如果直到检查完第n-1个参数都没有发现对应的文件,该指令就会立即跳转到
 第N个参数所指定的URI,对于上面的例子会内部跳转到/barz这个URI。


#nginx做本地缓存(模拟cdn?)
 配置文件如下:
 	http{
		#模拟后端应用,比如tomcat
       	server {
			listen 8080;
		
			location ~* ^/app.action {
                #设置前端可以缓存的时间,对于http/1.1协议,下面两个头都可以,但
 				#max-age的优先级高; 对于1.0则只识别Expires头.
				Expires: Fri, 13 Feb 2016 13:30:27 GMT;  
				Cache-Control: max-age=60;
				
				#设置Last-Modified头,决定客户端是否返回304
 				Last-Modified: Fri, 13 Feb 2015 13:30:27 GMT	
				
 				#输出内容
				content_by_lua 'ngx.say(os.clock())';
			}
		}        

        
		#--------------------华丽的分割线-----------------------
		#后端应用
		upstream tomcat_ {
			server 127.0.0.1:8080 weight=1;
		}
	
	    #分别代表:缓存的文件存入磁盘的位置; 存入文件深度;  共享内存的名字和大小
		proxy_cache_path /My/work/nginx/nginx/ccc levels=1:2 keys_zone=abc:1m;	

	    #前端代理nginx
		server {
			listen 80;
			server_name test;
		
			location ~* ^/cdn {
				rewrite /  /app.action break;  #rewrite到后端应用

				#指定共享缓存名字
				proxy_cache abc;       
				#指定缓存key,如果当前参数name=zs, 那么
                #这个缓存key就是 test/app.actionzs
				proxy_cache_key  $host$uri$arg_name 
				#指定对那种响应状态码缓存,以及缓存时间,
				#这里的时间可以被后端应用的Expires和Cache-Control:max-age=60覆盖 				
				#proxy_ignore_headers  Expires Cache-Control 忽略后端的两个头
				proxy_cache_valid 200 301 302  1s;
				#使用HTTP/1.1协议请求后端应用
				proxy_http_version 1.1;

				proxy_pass http://tomcat_;
			}
		} 
	}  

   注意:使用proxy_cache指令,缓存虽然过期了,但是并没有被删除,可以用purge模块的 
     proxy_cache_purge 指令去删除缓存。
	 例如:
		location ~ /purge {
			#abc是共享缓存的名字
			proxy_cache_purge abc $arg_key;
		}	

#upstream max_fails等参数的理解
	upstream backend {
		server 127.0.0.1:8080	max_fails=3  fail_timeout=2s;
		server 127.0.0.1:8081	max_fails=3	 fail_timeout=3s;
		
		//在fail_timeout时间内,如果发生了max_fails次失败,那么在fail_timeout时间内
		//就不会再访问server。 
		//如何定义max_fials认为的失败,则由proxy_next_upstream指令定义
    }

    location / {
		proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;
		proxy_connect_timeout	1s;  //和后端建立连接的超时时间,默认60s	
		proxy_read_timeout		1s;	 //两个read操作之间的超时时间,不是整个响应,默认60s
		proxy_pass	http://backend;
	
		//proxy_next_upstream 默认值error timeout
		//error  建立连接失败,传递请求失败,读取响应头失败都算error
        //timeout 建立连接、传递请求、读取响应头超时都算timeout
		//invalid_header 上游返回空或无效的响应算invalid_header
		//http_500	返回500算http_500
    }
  

#Nginx代码的目录结构
  core: 存放core module的代码,也是ngxin服务的入口
  http:	http core module的代码,ngxnx作为web/http proxy server运行时的核心模块
  mail: mail core module代码,nginx作为pop3/imap/smtp proxy server的核心模块
  event:ngxin自身对事件处理逻辑的封装
  os: nginx对各个平台抽象逻辑的封装
  misc: nginx的一些utils,定义了test和profiler的一些外围模块的逻辑

#NGINX处理请求大致流程
  1.客户请求开始

  2.从ngx_http_init_request开始处理请求,该函数会设置请求事件为
    ngx_http_process_request_line函数

  3.ngx_http_process_request_line用来处理请求行,在该函数中会调用
	ngx_http_read_request_header函数来读取请求。而处理请求用
	ngx_http_parse_request_line函数来处理请求行。
    当请求行处理完毕后,Nginx就会改变Tcp读事件的Handler为
    ngx_http_process_request_headers函数。

  4.到此,在遇到读事件后就会调用ngx_http_process_request_headers函数
    该函数的作用就是循环读取解析一系列的请求头。过程如下:
	调用ngx_http_read_request_header函数读请求头数据
	调用ngx_http_parse_header_line函数处理请求头
	将解析到的名字在ngx_http_headers_in中找对应的handler并调用
  
  5.请求头处理完成后调用ngx_http_process_request来处理请求。
    该函数将当前的读写事件处理函数都设置为ngx_http_request_handler
	而ngx_http_request_handler会根据事件的类型来调用read_event_handler
	或者write_event_handler。
    此时的read_event_handler为ngx_http_block_reading函数,即不读数据,
	也就是说此时还没有读取请求体。
	
  6.真正处理发生在ngx_http_handler函数中。?在这里处理请求体?
    该函数设置写事件函数write_event_handler为ngx_http_core_run_phases,
	并执行该函数。
	ngx_http_core_run_phases就是nginx留给我们的对外接口,总共有11个阶段。

  7.当所有的阶段处理完后会
	7.1调用header filter中的所有filter,最后一个是ngx_http_header_filter,该filter
       会调用ngx_http_write_filter将头输出。
  
	7.2调用body filter中的所有filter,最后一个是ngx_http_write_filter,该filter
	   对body进行输出。

#Ngxin中的基本数据结构	
##Nginx中的ngx_str_t字符串结构 
  src/core/ngx_string.h|ngx_string.c
  
  typedef struct {
 	size_t	len;
 	u_char	*data;
  }
 
##ngx_pool_t数据结构,用来管理资源
  src/core/ngx_palloc.h|ngx_palloc.c
 
  typedef struct ngx_pool_s	ngx_pool_t;
  struct ngx_pool_s {
 	ngx_pool_data_t		d;
 	size_t				max;
 	ngx_pool_t			*current;
 	ngx_chain_t			*chain;
 	ngx_pool_large_t	*large;
 	ngx_pool_cleanup_t	*cleanup;
 	ngx_log_t			*log;
  };
 
##nginx中的数组
  src/core/ngx_array.h|ngx_array.c
 
  typedef struct ngx_array_s		ngx_array_t;
  struct ngx_array_s {
 	void		*elts;
 	ngx_uint_t	nelts;
 	size_t		size;
 	ngx_uint_t	nalloc;
 	ngx_pool_t	*pool;
  }
 
##ngx_hash_t
  src/core/ngx_hash.h|ngx_hash.c
  
  //hash元素key-value键值对
  typedef struct {
     void             *value;   //value值
     u_short           len;	   //值的长度
     u_char            name[1]; //key   ?中括号什么意思
  } ngx_hash_elt_t;
 
  //hash结构
  typedef struct {
     ngx_hash_elt_t  **buckets;   //hash桶(size个)
     ngx_uint_t        size;		 //hash桶个数
  } ngx_hash_t;
 
  hash表中对于常用的解决冲突的方法有线性探测,二次探测和开链法等。ngx_hash_t
  中使用的是和java中HahsMap一样的方式开链法。当ngx_hash_t中的开链并不是真的
  开了一个链表。
 
  从ngx_hash_t这个hash结构可以看到,该结构有size个(*buckets),一个(*buckets)
  代表一个桶,这一个桶里面放置了好多的ngx_hash_elt_t元素,实际上每个桶指向的
  就是一个ngx_hash_elt_t元素的数组。
 
  如果和java中的HashMap对比的话,可以看到**buckets对应HashMap中的数组,而size
  就代表数组的大小。nginx中的每一个桶(*buckets)对应java中数组的一个元素。
  最后两者不同的是,java每个数组的元素用链的方式将冲突的key连接起来,而nginx中
  每个桶(*buckets)用"数组"的方式将其链接起来。
 
 
  nginx中的hash表只能一次初始化构建起整个hash表,后续不能删除和插入。
 
##ngx_hash_wildcard_t
  该hash表是为了处理带有通配符的域名匹配问题。该表支持两种通配符的域名。
  1.形如 *.aaa.com,.aaa.com,这样的key可以匹配www.aaa.com,b.a.aaa.com。
  2.形如 aaa.*,该key可以匹配aaa.com,aaa.cn等域名。
 
  需要注意的是,一个该结构类型的hash表只能匹配一种上述一种类型的key。
  ngx_hash_find_wc_head用来匹配通配符在前的key
  ngx_hash_find_wc_tail用来查找通配符在后的key
 
##ngx_hash_combined_t hash表的一个组合
  typedef struct {
 	ngx_hash_t			hash;    //普通hash表
 	ngx_hash_wildcard_t *wc_head;//通配符在前的hash表
 	ngx_hash_wildcart_t *wc_tail;//通配符在后的hash表
  } ngx_hash_combined_t;
 
  查找时会依次从这三个hash表中查找,一单找到,立即返回,只返回一个。
 
##ngx_hash_keys_arrays_t 
  src/core/ngx_hash.h|c
  该结构用来方便我们创建上面三种hash表而存在的辅助类型
 
  typedef struct {
       ngx_uint_t        hsize;
   
       ngx_pool_t       *pool;
       ngx_pool_t       *temp_pool;
   
       ngx_array_t       keys;
       ngx_array_t      *keys_hash;
   
       ngx_array_t       dns_wc_head;
       ngx_array_t      *dns_wc_head_hash;
   
       ngx_array_t       dns_wc_tail;
       ngx_array_t      *dns_wc_tail_hash;
  } ngx_hash_keys_arrays_t;

##ngx_chain_t 
  src/core/ngx_buf.h|c
  typedef struct ngx_chain_s ngx_chain_t;

  struct ngx_chain_s {
	ngx_buf_t 	*buf;
	ngx_chain_t	*next;
  }

##ngx_buf
  src/core/ngx_buf.h|c
  struct ngx_buf_s {
      u_char          *pos;
      u_char          *last;
      off_t            file_pos;
      off_t            file_last;
  
      u_char          *start;         /* start of buffer */
      u_char          *end;           /* end of buffer */
      ngx_buf_tag_t    tag;
      ngx_file_t      *file;
      ngx_buf_t       *shadow;
  
  
      /* the buf's content could be changed */
      unsigned         temporary:1;
  
      /*
       * the buf's content is in a memory cache or in a read only memory
       * and must not be changed
       */
      unsigned         memory:1;
  
      /* the buf's content is mmap()ed and must not be changed */
      unsigned         mmap:1;
  
      unsigned         recycled:1;
      unsigned         in_file:1;
      unsigned         flush:1;
      unsigned         sync:1;
      unsigned         last_buf:1;
      unsigned         last_in_chain:1;
  
      unsigned         last_shadow:1;
      unsigned         temp_file:1;
  
      /* STUB */ int   num;
  };

##ngx_list_t ngxin中的list数据结构
  src/core/ngx_list.h|c

  //list结构
  typedef struct {
	ngx_list_part_t *last; //指向该链表的最后一个节点
	ngx_list_part_t  part; //头结点
	size_t			size;  //具体元素所需要的内存大小;?每个,还是总共
	ngx_unit_t		nalloc;//每个节点可包含的具体元素的个数
	ngx_pool_t		*pool; //该list使用的分配内存的pool
  } ngx_list_t;

  //list结构中的节点
  typedef struct ngx_list_part_s ngx_list_part_t;
  struct ngx_list_part_s{
	void			*elts; //每个节点存放具体元素的开始地址,可以理解为一个数组(elts[])
	ngx_unit_t		nelts; //该节点包含的元素的个数
	ngx_list_part_t *next; //该节点指向的下一个节点
  } 
  
 ##ngx_queue_t ngxin中的双向链表
   src/core/ngx_queue.h|c

   typedef struct ngx_queue_s ngx_queue_t;
   struct ngx_queue_s {
		ngx_queue_t		*prev;
		ngx_queue_t		*next;
   };

   可以看到这个双向链表没有,节点中没有数据成员,只有前一个和后一个,在使用的时候需要
   先定义个哨兵:

   		ngx_queue_t free;  //哨兵,不放任何数据,prev指向链表头,next指向第一个节点

   使用一个具有数据元素的链表节点时,只要在相应的结构体上加一个ngx_queue_t成员就可以。
   比如:

    	typedef struct { //加上一个ngx_queue_t后,这就是一个该queue的具体数据
			int 			a;
			ngx_queue_t		queue; //代表一个链表节点
			char			*name;
    	} mydata;

  当我们知道 ngx_queue_t *q 指向的是链表中queue后,我们可以通过queue在mydata
  中的偏移量,来获取mydata的地址:
	1.获取queue在mydata结构体中的偏移量  
	  size_t offset = offsetof(mydata,queue);	
 	2.让queue的具体地址减去偏移量,这个就是mydata的地址  
	  mydata data = (mydata)((char *)q - offset);  

#Nginx的请求处理
 ngxin的所有业务逻辑都在worker进程处理,worker进程中的ngx_worker_process_cycle()
 函数做一个无限循环操作,不断接收客户端的请求并处理,大致流程如下:
	1.等待操作系统产生相关的事件
	2.接收和处理这些事件,将接收到的数据产生更高层的request对象
	3.处理request中的header和body
	4.产生响应,并发送回客户端
	5.完成request的处理
	6.重新初始化定时器及其他事件

 从内部来看,一个Http Request的处理过程涉及以下几个阶段:
	1.初始化Http Request
	2.处理请求头
	3.处理请求体
	4.如果有的话,调用与此请求关联的handler
	5.依次调用各个phase handler进行处理(11个阶段)

#Nginx模块开发

##Nginx模块的配置结构,该结构用来存储我们需要的中间值
  每个模块可以用三个不用的数据结构,去存储该模块在main,server,location三个作用
  域的配置信息。

  对于模块配置信息的定义,命名习惯像这样ngx_http_<module name>_<main|src|loc>_conf_t  
  比如我们定义如下一个结构,来存储我们的模块在location区域的配置信息:
	typedef struct{
		ngx_str_t	hello_string_tmp;
		ngx_int_t	hello_counter_tmp;
		ngx_str_t	hello_tmp;
	}ngx_http_hello_loc_conf_t;  

  在处理数据时我们可以用这个结构保存我们的一些信息,比如我们在读完指令和指令参数
  后,把这些信息可以放到这个结构体中,如果不需要也可以不放。 

##Ngxin指令配置结构
  nginx中的每个模块都需要通过一些指令来完成任务,指令的结构体如下:
  
  src/core/ngx_core.h
  typedef struct ngx_command_s     ngx_command_t;
  
  src/core/ngx_conf_file.h
  struct ngx_command_s {
	ngx_str_t		name;   //指令名字
	ngx_uint_t		type;   //指令的一些属性,如参数个数,指令可在位置等 
	char			*(*set)(ngx_conf_t *cf,ngx_command_t *cmd,void *conf);
	ngx_uint_t		conf;   //该配置应该存放的内存位置
	ngx_unit_t		offset; //该配置项精确存放的位置
	void			*post;	
  }

  下面解释下ngx_commands_s结构体中字段的含义:
  name: 指令的名字
  type: 该指令属性的一些配置值,可以组合起来使用
	  NGX_CONF_NOARGS: 该指令不接受任何参数
	  NGX_CONF_TAKE1:  该指令只接受一个参数
	     。。。
	  NGX_CONF_TAKE7:  该指令只接受七个参数
	
	  NGX_CONF_TAKE12: 该指令只接受1个或2个参数
	  NGX_CONF_TAKE13: 接受1或3个参数
	  NGX_CONF_TAKE23:
	  NGX_CONF_TAKE123:
	  NGX_CONF_TAKE1234:
	  NGX_CONF_1MORE: 至少一个参数
	  NGX_CONF_2MORE: 至少两个参数
	  NGX_CONF_MULTI: 可以接受多个
	  NGX_CONF_BLOCK: 可以接受一个配置块{} 
	  NGX_CONF_FLAG: 可以接受on或off字符,最终转换为bool
	  NGX_CONF_ANY:	 可以接受任意的参数值,比MULTI更宽泛
	   
	  NGX_DIRECT_CONF: 该指令可以出现在配置文件的最外层,如daemon指令
	  NGX_MAIN_CONF: 出现在http,main,events,error_log等
	  NGX_ANY_CONF: 可以出现在任意区域
	 
	  NGX_HTTP_MAIN_CONF: 可以出现在http区域
	  NGX_HTTP_SRV_CONF: 可以出现在http中的server域中
	  NGX_HTTP_LOC_CONF: 可出现在http server块的location中
	  NGX_HTTP_UPS_CONF: 可出现在 upstream中
	  NGX_HTTP_SIF_CONF: server中的if域中
	  NGX_HTTP_LMT_CONF: 出现在limit_except中
	  NGX_HTTP_LIF_CONF: 出现在location中得if域中   
   
  set:函数指针,用处理指令配置信息的函数,这个函数是我们自定义的,当nginx解析完
      配置信息后,就会调用该函数并传递其解析的数据,该函数原型如下:
      
      //处理成功返回NGX_OK,否则返回NGX_CONF_ERROR或者我们自己定义的字符串
	  char *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf); 
	   
		cf:这个参数保存我们从配置文件读取到的原始字符串,ngx_conf_t中的args字
		   段是一个ngx_str_t类型的数组,值分别是:指令本身、第一个参数、第二个
		   参数,直到最后一个参数。
	    cmd:该配置指令对应的ngx_command_t结构
		conf:我们自定义的结构体,该结构体可以存储一些的信息
			 ?我们自己赋值,还是nginx帮我们赋值?必须用下面的函数才会自动赋值?
	
  为了方便对指令参数的读取,nginx提供了一些默认的函数,这些函数可以直接赋值给set
  字段使用: ?是不是只有使用这些函数,ngx_command_s中的offset字段才有意义,才会自动为我们自定义的结构体赋值
	ngx_conf_set_flag_slot: 读取NGX_CONF_FLAG类型的参数。将on或off转换成1或0。
    ngx_conf_set_str_slot:读取字符串类型的参数。将字符串保存为ngx_str_t。
    ngx_conf_set_str_array_slot: 读取字符串数组类型的参数。
    ngx_conf_set_keyval_slot: 读取键值对类型的参数。
    ngx_conf_set_num_slot: 读取整数类型(有符号整数ngx_int_t)的参数。
    ngx_conf_set_size_slot:读取size_t类型的参数。如解析8k,1m并将其保存为size_t。
    ngx_conf_set_off_slot: 读取off_t类型的参数。
    ngx_conf_set_msec_slot: 读取毫秒值类型的参数。
    ngx_conf_set_sec_slot: 读取秒值类型的参数。
    ngx_conf_set_bufs_slot: 读取的参数值是2个,一个是buf的个数,一个是buf的大小。
							例如： output_buffers 1 128k;
    ngx_conf_set_enum_slot: 读取枚举类型的参数，将其转换成整数ngx_uint_t类型。
    ngx_conf_set_bitmask_slot: 读取参数的值,并将这些参数的值以bit位的形式存储。
							   例如：HttpDavModule模块的dav_methods指令。	
	ngx_http_set_complex_value_slot: 解析一个包含nginx变量的字符串并保存为ngx_http_complex_value_t。
    //更多处理函数参见ngx_conf_file.h

  conf: 指定把这些配置信息存放到哪个内存区域。
		http模块对所有要保存的配置信息,划分了main,server和location进行存储,分别
		对应值为NGX_HTTP_MAIN_CONF_OFFSET,NGX_HTTP_SRV_CONF_OFFSET,
		NGX_HTTP_LOC_CONF_OFFSET
		
		其中在main中解析到的指令只会放到main_conf上下文中,依次类推在server和location
        区域中解析到的指令也只会放到各自的上下文中。

		然而由于某些指令可以在不同的区域中使用,并且如果本区域没有配置的话,下级区域可以
        继承上级区域的指令,所以在ngx_http_module_t模块上下文中可以看到有merge类的回调
        函数去合并指令。

  offset: 该指令值的精确存放位置,就是我们自定义的结构体的,某个字段的偏移量
		  ?也就是说nginx回自动为我们的结构体赋值?

  post: 存储一个指针。一般不需要指定,可以指定为NULL

  例子,指定某个模块的指令集:
	static ngx_command_t ngx_http_hello_commands[] = {
		{
			//ngx_str_t name 
			//指令名字
			ngx_string("hello_string"),

			//ngx_uint_t type
			//该指令可以在location域,且只能有一个参数
			NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,

			//char *(*set)(ngx_conf_t *cf,ngx_command_t *cmd,void *conf)
			// cf原始参数
			// cmd 该指令对应的ngx_command_t结构本身
			// conf 我们自定义的结构体
			//处理该指令的函数
			ngx_http_hello_string,
			
			//ngx_uint_t  conf
			//该指令信息的内存存放区域
			NGX_HTTP_LOC_CONF_OFFSET,
			
			//ngx_uint_t offset
			//该指令的值存储的精确内存地址,_loc_conf_t是我们自定义的结构体
			offsetof(ngx_http_hello_loc_conf_t,hello_string),

			//void *post
			NULL
		},

		//其他指令
		//{},

		ngx_null_command   //数组最后用该结构结尾
	}

#模块的上下文结构 ngx_http_module_t
 该结构体中存放的是一些函数,这些函数会在配置信息的创建前和创建后调用,
 这个结构体最终会注册到ngx_module_t中。这里的函数其实就是在读取配置信息前后,
 或者初始化配置信息前后调用。只有在nginx启动时调用,用来读取并保存配置信息。

  src/http/ngx_http_config.h
  typedef struct {
   4   ngx_int_t   (*preconfiguration)(ngx_conf_t *cf);
   8   ngx_int_t   (*postconfiguration)(ngx_conf_t *cf);
  
   1   void       *(*create_main_conf)(ngx_conf_t *cf);
   5   char       *(*init_main_conf)(ngx_conf_t *cf, void *conf);
  
				  //create之后会调用该模块的指令处理函数,这些指令函数会将解析到的指令值放入到该
				  //创建的自定义结构中,然后merge_src被调用进行合并
   2   void       *(*create_srv_conf)(ngx_conf_t *cf);
   6   char       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf);
  
   3   void       *(*create_loc_conf)(ngx_conf_t *cf);
   7   char       *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void *conf);
  } ngx_http_module_t;

 这些回调函数都是在http/ngx_http.c 文件中被调用的,具体可以搜module->
 
 preconfiguration: 在创建和读取该模块的配置信息之前调用
 postconfiguration: 模块的配置信息都被设置完后调用,最后执行该方法

 create_main_conf: 创建http域的配置信息的结构体?成功就返回创建的结构体。
				   失败就返回NULL。
 init_main_conf: 初始化这个http域的结构体,成功返回NGX_CONF_OK,失败返回
				 NGX_CONF_ERROR或错误字符串。因为main域上面没有其他域了,所以
				 这里没有merge这个操作。
 
 create_srv_conf: 创建每个server域的存储结构体。 
 merge_srv_conf: 合并配置信息,如果当前没有就用上层的。

 create_loc_conf: 创建每个location域的存储结构体,并初始化它。
				  这里的结构体就是我们自定义结构体,比如http_hello_loc_conf_t
				  我们只需要创建并初始化它,然后返回即可。
 merge_loc_conf:  这个方法会在create_loc_conf函数和ngx_command_t中的set关联的函数
 				  调用之后再执行。

				 大概意思可能就是,比如ngx_http_hello_loc_conf_t这个结构体中有
				 一个expires这个字段,这个值在当前域中可以用,在上层域或下层域中
				 都可用,那么如果该指令在当前为定义就是用上层的值

##调用顺序
 调用main方法
 调用ngx_init_cycle
 通过ngx_conf_parse方法解析顺序解析配置文件,该方法会每解析到一个指令就调用他指定的方法
 当解析到http指令后,调用http指令指定的方法ngx_http_bloc
 ngx_http_block方法
  1.调用每个模块的create_main_conf、create_srv_conf、create_loc_conf方法
  2.调用每个模块的preconfiguration
  3.调用ngx_conf_parse方法去解析http{}中的指令,按顺序解析
  4.每遇见一个指令就调用该指令指定的处理方法.当解析到server指令后,
    调用server指令指定的方法ngx_http_core_server
  5.ngx_http_core_server方法调用每个模块的create_srv_conf、create_loc_conf方法  
  6.ngx_http_core_server之后调用ngx_conf_parse方法解析server{}内部的指令
  7.当解析到第一个location指令后,调用location指令指定的方法ngx_http_core_location
  8.ngx_http_core_location方法调用每个模块的creat_loc_conf方法
  9.ngx_http_core_location之后ngx_conf_parse方法解析location{}内部的指令
  10.调用每个模块的init_main_conf方法
  11.调用每个模块的merge(merge_srv、merge_loc)
  12.调用每个模块的postconfiguration


##对以上这个回调方法的调用顺序做一个详细解释
  配置文件如下,并标出各个指令可以存在的区域
  http{
  	server_names_hash_bucket_size 64; //Context:http
	client_header_timeout 60s; //Context:http,server	
	root	/export/masf;	//Context:http,server,location,if in location

	server{
		access_log	off;  //Context:http,server,location	
		listen	80;	      //Context:server
		expires 60s;      //Context:http,server,location
			
		location ~ ^/masf {
			expires 6s;	  //Context:http,server,location
		}
	}
  }

  首先,对于从配置文件解析到的指令数据应该放到哪里,nginx为我们准备了三种坑位,
  在ngx_command_t中可以用NGX_HTTP_MAIN_CONF_OFFSET、NGX_HTTP_SRV_CONF_OFFSET、
  NGX_HTTP_LOC_CONF_OFFSET这三种配置来指定。
  具体存放指令信息的结构体我们需要自己定义,这个结构会被放到哪个坑位,则有上面三
  个配置指定。

  通常在nginx中有这样一种默契,如果一个指令可以配置在http、server块中,那么该指令
  被解析完后应该放在NGX_HTTP_SRV_CONF_OFFSET坑位中,因为如果放在LOC_CONF中会有冗
  余,放在MAIN_CONF中有覆盖。
  (因为把原本应该在SRV_CONF块中的指令解析到MAIN_CONF中,那SRV_CONF中就会没有值,这
   时候如果server块和http块中都配置了某个指令,在merge_conf的时候虽然server中有指
   令,但SRV_CONF结构体中且没有值,所有上层配置会覆盖下层配置)
   
  现在我们来看看上面配置文件中每个指令应该存放的坑位:
  http块
  main_conf
	server_names_hash_bucket_size 64
  srv_conf
 	client_header_timeout 60s
  loc_conf
	root	/export/masf

  server块(可以有多个)
	srv_conf
	  listen 80
	loc_conf
	  access_log off

    location块(可以有多个)
      loc_conf
		expires 6s
  
  我们可以的出ngx_http_module_t结构中的回调函数的顺序是这样的,和指令顺序没有关系:
  1.对于每一个模块nginx依次调用create_(main|srv|loc)_conf函数,用来存放该模块在http块
     配置的指令信息。?如果在该区域发现该模块的某个指令,则调用响应的指令函数赋值?
  2.调用preconfiguration 
  3.在server块,依次调用create_(srv|loc)_conf函数,来存放该模块在server区域的指令。
    (在这个块中找到所有该模块的指令,并调用其指令处理函数将值存入相应的机构体中?)
  4.在location块,调用create_loc_conf函数,存放location区域中该模块的指令
  5.调用init_main_conf,做一些初始化操作
  6.依次调用merge_(srv|loc)_conf函数,合并该模块在server块中的指令值
  7.调用merge_loc_conf函数,合并该模块在location块中的指令值 
  8.最后调用postconfiguration


#模块定义 ngx_module_s 表示我们编写的某个模块
 nginx中的每一个模块都要定义一个ngx_module_s结构体来描述自己,这个结构体中
 包含了模块的上下文结构(ngx_http_module_t)、指令信息(ngx_command_t)等

 src/core/ngx_core.h
 typedef struct ngx_module_s ngx_module_t;

 /core/ngx_conf_file.h
 struct ngx_module_s {
    ngx_uint_t            ctx_index;  //该模块在request->ctx中的索引
    ngx_uint_t            index;
    ngx_uint_t            spare0;
    ngx_uint_t            spare1;
    ngx_uint_t            spare2;
    ngx_uint_t            spare3;
    ngx_uint_t            version;

    void                 *ctx;
    ngx_command_t        *commands;
    ngx_uint_t            type;

    ngx_int_t           (*init_master)(ngx_log_t *log);
    ngx_int_t           (*init_module)(ngx_cycle_t *cycle);
    ngx_int_t           (*init_process)(ngx_cycle_t *cycle);
    ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);
    void                (*exit_thread)(ngx_cycle_t *cycle);
    void                (*exit_process)(ngx_cycle_t *cycle);
    void                (*exit_master)(ngx_cycle_t *cycle);
    uintptr_t             spare_hook0;
	...
	uintptr_t			  spare_hook7;
 }

 #define NGX_MODULE_V1          0, 0, 0, 0, 0, 0, 1
 #define NGX_MODULE_V1_PADDING  0, 0, 0, 0, 0, 0, 0, 0 

 有了这个结构之后nginx核心就知道我们模块的信息了,但是还差一个真正处理
 我们请求的函数,这个结构上并没有体现,这个函数的声明如下:
	
	typedef ngx_int_t (*ngx_http_handler_pt) (ngx_http_request_t *r);
 
 该函数处理成功返回NGX_OK,发生错误返回NGX_ERROR,留给后续的handler进行处理
 返回NGX_DECLINE。

 这个函数可以通过两种方式挂载到处理过程中
  1.按阶段挂载
  2.按需挂载

 Nginx把处理过程分成了11个阶段
  NGX_HTTP_POST_READ_PHASE  //读取请求内容阶段
  NGX_HTTP_SERVER_REWRITE_PHASE //Server请求地址重写阶段
  NGX_HTTP_FIND_CONFIG_PHASE //配置查找阶段
  NGX_HTTP_REWRITE_PHASE	//location 请求地址重写阶段
  NGX_HTTP_PREACCESS_PHASE	//访问权限检查准备阶段
  NGX_HTTP_ACCESS_PHASE	   //访问权限检查阶段
  NGX_HTTP_TRY_FILES_PHASE //配置项try_files处理阶段
  NGX_HTTP_CONTENT_PHASE	//内容产生阶段
  NGX_HTTP_LOG_PHASE		//日志处理阶段 
 
  一般挂载动作发生在模块的上下文调用postconfiguration函数中,例如:
 	
	static ngx_int_t ngx_http_hello_init(ngx_conf_t *cf){
		ngx_http_handler_pt			*my_h;
		ngx_http_core_main_conf_t	*cmcf;

		cmcf = ngx_http_conf_get_module_main_conf(cf,ngx_http_core_module);
		
		my_h = ngx_array_push(&cmcf->phases[NGX_HTTP_CONTENT_PHASE].handlers);
		if (my_h == NULL){
			return NGX_ERROR;
		}
		
		//挂载我们真正处理请求的函数
		*my_h = ngx_http_hello_handler;

		return NGX_OK;
	}
 
 这种方式也称为content phase handlers,其中以下4个阶段不允许挂载任何handler
 	NGX_HTTP_FIND_CONFIG_PHASE
 	NGX_HTTP_POST_ACCESS_PHASE
 	NGX_HTTP_POST_REWRITE_PHASE
 	NGX_HTTP_TRY_FILES_PHASE

 另一种挂载方式叫做content handler。
 这种挂载方式只有执行到NGX_HTTP_CONTENT_PHASE阶段的时候才会执行,并且在该阶段
 注册的所有handler都将失效。?章宜春说的是这种方式? 
 挂载例子如下:
	
	static char *ngx_http_circle_gif(ngx_conf_t *cf,ngx_command_t *cmd,void *conf){
		ngx_http_core_loc_conf_t	*clcf;
		
		clcf = ngx_http_conf_get_module_loc_conf(cf,ngx_http_core_module);
		clcf->handler = ngx_http_circle_gif_handler;

		return NGX_CONF_OK;
	}
 

#响应头过滤函数
 入口只有一个:
	
	ngx_int_t ngx_http_send_header(ngx_http_request_t *r){
		...
		return	ngx_http_top_header_filter(r);
	}

#响应体过滤函数
 可能被执行多次,入口函数是:

	ngx_int_t ngx_http_output_filter(ngx_http_request_t *r,ngx_chain_t *in){
		...
		rc = ngx_http_top_body_filter(r,in);
		...
		return rc;
	}

  Nginx的响应内容都存于in(ngx_chain_t,单链表 )中,并且链表不会太长。链表中每个ngx_chain_t
  都有一个ngx_buf_t用来缓存数据,其实这个buf结构体记录了响应的开始地址和结束地址,但对于
  静态文件,会被实际分配32K,一次吐不完就多吐多次。对于反向代理在4k或8k。

  在响应体过滤中,ngx_buf_t结构体的标志位特别重要。如buf中有last标志,说明是最后一块buf,
  可以直接输出并结束请求了。
    
#子请求
 在过滤模块中可以发送新的子请求,当子请求发出时会调用ngx_http_subrequest函数,该函数
 将子请求的r->postponed链表中,当父请求的响应体处理完毕后会依次处理链表中的所有子请求
 ,并且每个子请求都会有一个完整的请求处理过程。

#upstream
 nginx的模块可以分为三类:handler,filter,upstream
 前两种模块可以完成单机操作,upstream可以跨越单机。
 
 开发不同的upstream模块只需要实现几个回调函数来完成构造请求和解析响应等。
 回调函数如下:
 create_request  创建请求需要的数据,比如某种协议的请求
 reinit_request  
 process_header  处理后端服务器返回的信息头部
				 nginx在处理后端服务的响应头时只用一块缓存,所有的数据都在
				 这个缓存中,所以解析头部信息时不需要考虑跨多块缓存的情况。
				
				 该函数的重要职责是将后端服务器返回的状态翻译成返回给客户端
                 的状态。处理完头部信息后pos指针要后移,否则头部信息也会被输出
     			 到响应体中。

				 如果头部大小大于缓存的大小,nginx会返回错误信息给客户端,并
 				 记录log。(?全是这样,还是只有memcached模块是这样)
 abort_request
 finalize_request
 input_filter
 input_filter_init

#Nginx源码目录结构
 auto    	用来检测系统环境以及编译相关的脚本
     cc  	检测编译器相关的编译选项
     lib	编译nginx需要的一些库的检测,比如prce
	 os     于平台相关的检测
     types  与数据相关的一些辅助脚本
 
 conf		默认配置文件,最后会拷贝到安装目录
 contrib	存放一些工具,geo等
 html		默认存放的网页文件
 man 		nginx的man手册
 src		存nginx源代码
	core	核心源码
	event	对事件处理机制的封装
	http	作为http服务器相关的代码
	mail	作为邮件服务器相关的代码
	misc	一些辅助代码,测试c++头的兼容性,以及对google_perftools的支持
	os		对各种不同操作系统提供的系统函数的封装,对外提供统一的系统接口

#nginx中configure原理 
 初始化
 . auto/options
 . auto/init
 . auto/sources
 auto/options用于处理用户输入的configure选项,该配置包含了configure文件都有
 那些选项,比如--prefix、--add-moudle等选项

 auto/init用于初始化临时文件路径，并创建Makefile
    //生成最终执行编译的makefile文件路径
    NGX_MAKEFILE=$NGX_OBJS/Makefile

 auto/sources定义不同功能或系统所需的文件的变量

 当这个脚本执行完后,在./objs/ngx_auto_config.h中会保存用户都输入了那些选项
 比如#define NGX_CONFIGURE " --prefix=/export/servers/ --add-module=/usr/local/src/ngx-module/"

#模块的执行顺序
 从obj/ngx_modules.c中可以看到模块的执行顺序,对于不同模块在相同阶段的指令
 其执行顺序和该文件中的模块的顺序一致。第三方的模块永远在最后执行。

 注意,该文件中http filter模块会将所有的filter排成一个倒序链,所以filter
 模块的执行顺序和文件中的顺序是相反的。  

 另外第三方的filter模块必须注册在&ngx_http_headers_filter_module和
 ngx_http_copy_filter_module之间。

#nginx启动阶段
 ngx_cycle_t结构用于存放 core模块的配置
 ngx_conf_t结构,用于存放解析配置的上下文信息

 配置文件的解析在ngx_conf_file.c中实现,提供的主要函数是ngx_conf_parse
 ngx_conf_param是对ngx_conf_parse的包装,用来解析命令行传递的配置。

 ngx_conf_parse方法分连个阶段解析配置，词法分析和指令解析
	词法分析通过ngx_conf_read_token函数完成

 在http/ngx_http.c 文件中,会调用nginx模块上下文中指定的回调函数,
 比如这样一段代码:
	for (m = 0; ngx_modules[m]; m++) {
    	if (module->postconfiguration) {
        	if (module->postconfiguration(cf) != NGX_OK) {
            	return NGX_CONF_ERROR;
       	 	}
    	}
    }
 回调各个模块的postconfiguration函数

#nginx请求处理阶段
 在初始化阶段,跟事件相关的初始化工作主要由ngx_event_process_init函数完成。
 该函数会为每一个要监听的套接字分配一个ngx_connection_t结构,并且将该结构
 的读事件处理函数设置为ngx_event_accept。
 这结构只代表这个监听端口,之后每来一个请求就重新分配一个ngx_conn_t结构。

 这个时候并没有将这个连接代表的socket挂到事件处理模型上,如果使用了accept锁
 则要在后面抢到锁才能将该connetion挂到事件模型上。
	if (ngx_use_accept_mutex) {
        continue;
    }
 如果没有使用accept锁则直接挂到事件模型上
	if (ngx_event_flags & NGX_USE_RTSIG_EVENT) {
           if (ngx_add_conn(c) == NGX_ERROR) {
               return NGX_ERROR;
           }

     } else {
		   //这里rev是ngx_event_t结构 
           if (ngx_add_event(rev, NGX_READ_EVENT, 0) == NGX_ERROR) {
               return NGX_ERROR;
           }
     }

 当某个监听事件挂载到事件模型上后,nginx就可以接收并处理客户端的请求了。
 当客户端的请求到来的时候,nginx的事件模型会接收到这个读事件,并交给之前
 注册好的事件处理函数ngx_event_accept来处理。

 ngx_event_accept函数会调用accept函数获取一个客户端链接,并为这个链接分配
 一个ngx_connetion_t结构,之后做一些初始化工作。  
 
 之后调用ngx_http_init_connetion函数来初始化读写事件的处理函数。
 其中写事件的处理函数是ngx_http_empty_handler,这个函数什么也不做,第一次
 也不会向事件模型注册写事件,如果有数据要写的话就直接写,只有在一次写不完
 的时候才会注册真正的写事件函数,并将写事件挂载到事件模型上。

 ngx_http_init_request是刚开始是注册的读事件。
 该函数的工作就是初始化请求,比如为该连接分配一个ngx_http_request_t结构
 并将其放在该连接的hc成员的request字段。
 该函数根据请求的端口号和地址找一个默认虚拟主机,比如listen指令的default_server属性。
 如果在后面能够找到匹配的虚拟主机,则会覆盖默认的设置。 

  1.之后ngx_http_process_request_line函数被设置为读事件处理函数

  2.分配缓冲区来保存请求头,默认缓冲区为1k,可以用client_header_buffer_size修改，
	如果客户端发过来的请求头大于1k,则会重新分配更大的缓冲区,最大为8k,最多4个
    也就是说单个请求头不能大于8k,所有请求头总大小不能大于32k。
    可以用large_client_header_buffers指令修改 

  3.为请求分配一个内存池,默认大小为4k,可用request_pool_size指令修改。 

  4.将请求的main字段设置为它本身,代表是一个主请求。

  5.将当前时间保存在start_sec和start_msec字段中,通过该时间可以计算请求处理
    所用的时间,也就是说在接收到客户端第一个数据为开始时间。

  6.初始化其他请求字段,比如uri_changes设置为11,表示最多可以将uri改写10次,
    subrequests设置为201,表示最多可以发起200个子请求。

  7.最后调用该连接的读事件处理函数来解析客户端的数据,也就是前面我们设置的
    ngx_http_process_request_line函数。

   至此ngx_http_init_request函数处理处理完毕,进入ngx_http_process_request_line函数。
 
##ngx_http_process_request_line函数的主要作用那个是解析请求行,因为涉及到
  IO操作,请求行可能不能被一次读完,所以在ngx_http_init_request函数中将其设置为
  读时间处理函数。
  
  该函数会调用ngx_http_read_request_header函数来读取请求行。读取后的数据会放
  到header_in指向的缓冲区中,每读一个字节r->header_in->last就会加1,尽可能多的读到数据之后返回。
  
  然后调用ngx_http_parse_request_line方法去解析请求行,在该方法中对应的缓存
  请求行的缓存header_in中得pos回一直减,代表已经解析到的数据。
  解析成功之后将解析到的数据保存到r结构体的相应的字段中。
     
##解析请求头
  headers_in中保存了所有请求头,类型为ngx_http_headers_in_t
  	typedef struct {
		ngx_list_t			headers;	//存放所有解析到的请求头
		
		//一些常用头,只是一些对解析到的常见头的一个引用
		ngx_table_elt_t		*host;		
		ngx_table_elt_t		*connection;
		ngx_table_elt_t		*if_modifed_since;
		...
	} ngx_http_headers_in_t;

  在ngx_http_process_request_line函数中,当解析完请求行之后,如果请求行
  的uri中包含了域名部分,那么或把它保存在 headers_int_t的server字段中:

	if (r->host_start && r->host_end){ //如果uri中有host
		host.len = r->host_end - r->host_start;
		host.data = r->host_start;
		
		rc = ngx_http_validate_host($host,r->pool,0);

		// 各种校验个判断 
		 .....
		
		r->header_in.server = host;
	}		

  然后判断请求是否用的是http0.9协议,如果是的话就省略处理请求头,直接
  调用ngx_http_process_request()函数处理请求,因为0.9没有请求头。
	
	if (r->http_version < NGX_HTTP_VERSION_10){ //判断是否是0.9协议
		if (r->headers_in.server.len == 0 && ngx_http_set_virtual_server(r,&r->headers_in.server == NGX_ERROR)){
			return;
		}

		ngx_http_process_request(r);
		return;
	}  

  如果是1.0以上的协议,则处理请求头,在处理之前先为headers这个链表进行初始化,
  为这个链表的初始节点分配了20个ngx_table_elt_t类型的空间。
	
	if (ngx_list_init($r->header_in.headers,r->pool,20,sizeof(ngx_table_elt_t))) != OK){
		ngx_http_close_request(r,NGX_HTTP_INTERNAL_SERVER_ERROR);
		return;
	}

  然后把读时间处理函数设置成ngx_http_process_request_headers,接着直接调用
  该函数来处理请求头.
	
	rev->handler = ngx_http_process_request_headers;
	ngx_http_process_request_headers(rev);

  直到这里才开始真正的进入到处理请求头函数并处理请求头。读取和解析请求行的
  处理逻辑相似,这里是在一个循环里面先调用ngx_http_read_request_header去读取
  请求头,如果当前连接没有数据过来,则直接返回并等待下一次事件到来,如果读到了
  就调用ngx_http_parse_header_line函数来解析,该函数一次调用只能解析一个请求头
  并且有3中不同的返回值。
  	1.返回NGX_OK 表示成功解析出了一行请求头,然后从ngx_http_headers_in[]中查找
      是否为该请求头绑定了处理函数,如果有的话就执行。数组在ngx_http_request.c中
     
      在该数组中共有25个常用请求头,每个请求头都绑定了处理函数,其中大部分都绑定
      的是公共处理函数,有两个这样的函数,ngx_http_process_header_line和
      ngx_http_process_unique_header_line, 第一个函数只是简单将解析到的请求头,
      在ngx_http_headers_in_t中保存一份引用。第二回检查是是否重复,如果是则返回
      400错误。

      剩下的都有自己得处理函数,比如host头的ngx_http_process_host函数,他的作用
      也是保存host头的一个引用,并且保存在headers_in.server字段中, 但是根据http
      协议的规范,如果请求行中带有域名则以请求行为准。所以这里会检查一下该字段
      是否为空,因为前面已经会对这个字段赋值。

   2.返回NGX_AGIAN 表示接收的数据不够解析完一个请求头,需继续下一个轮循。
     在轮循中首先检查header_in是否已满,如果满了就调用ngx_http_alloc_large_header_buffer
     函数来分配更大的缓冲区,如果客户端发送了一行过大的请求头,或整个请求头大小
     超过了限制则返回494错误。需要注意的是在nginx中每个请求头不能跨缓冲区,所以
     每个缓冲区的大小决定了请求头的大小。

   3.返回NGX_HTTP_PARSE_HEADER_DONE,表示所有请求已经解析成功,请求的状态被设置
     为NGX_HTTP_PROCESS_REQUEST_STATE,意味这请求读取阶段结束,正是进入请求处理
     阶段,nginx之所以没有在这里处理请求体,而是交给后续的请求处理阶段,是因为nginx  
     本身不知道这些请求体是否有用,如果后续模块不需要则白白浪费时间和内存空间。

   处理完请求头之后,nginx调用ngx_http_process_request_header函数,该函数先调用
   ngx_http_find_virtual_server函数查找虚拟服务器配置,然后对一些请求头做一些
   协议的检查,比如如果是http1.1协议但没发送host头,则返回400错误。

   最后调用ngx_http_process_request函数处理请求。

#读取请求体    
 请求体的读取一般发生在nginx的content handler中,比如proxy模块是一定会把客户端
 的请求体转发给后端服务器的。
 读取请求体有ngx_http_read_client_request_body函数完成,该函数会根据请求体的大小,
 以及相关指令配置,将请求体放入到内存、临时文件或者前一部分放内存剩余放文件中。
 
 client_body_buffer_size: 设置缓存请求体的buffer大小,默认为系统页大小的2倍,当
   请求体大于这个值时,会把剩余的请求体写入到临时文件中。?不确定是剩余

 client_body_in_single_buffer: 是否将请求体完整的存储在一块连续的内存中,默认off
   如果为on则如果缓存够用放在一块连续的内存中,否则全部放入一个临时文件
 
 client_body_in_file_only: 是否总是将请求体放在临时文件中,默认off

#丢弃请求体
 nginx核心提供的ngx_http_discard_request_body函数可以丢弃请求体。 

#多阶段处理请求
 NGX_HTTP_POST_READ_PHASE: 接收完请求头之后的第一个阶段
 NGX_HTTP_SERVER_REWRITE_PHASE: server级别的uri重写阶段
 NGX_HTTP_FIND_CONFIG_PHASE: 该阶段使用重写之后的uri来查找location
 NGX_HTTP_REWRITE_PHASE: location级别的uri重写阶段
 NGX_HTTP_POST_REWRITE_PHASE: 用来检查上阶段是否有uri重写,并根据结果调到合适的阶段
 NGX_HTTP_PREACCESS_PHASE
 NGX_HTTP_ACCESS_PHASE
 NGX_HTTP_POST_ACCESS_PHASE
 NGX_HTTP_TRY_FILES_PHASE
 NGX_HTTP_CONTENT_PHASE
 NGX_HTTP_LOG_PHASE :记录访问日志,进入该阶段表明该请求的响应已经发送到系统send_buffer

##多阶段执行链
 以上的前十个阶段都是在ngx_http_core_run_phases函数中执行的,所以在这个过程中
 链接的读事件会一直是这个函数。

 LOG阶段的handler链运行在ngx_http_free_request函数中,具体执行函数是ngx_http_log_request

#Nginx filter
 在Content阶段将产生的数据发往客户端之前,会先经过过滤。   

##header filter
  通常调用ngx_http_send_header函数来发送响应头,该函数又调用ngx_http_top_header_filter(r)
  来发送。

##body filter
  调用ngx_http_output_filter发送响应头,该函数又调用ngx_http_top_body_filter(r,in)

#ngx_http_copy_filter_module 模块

#ngx_http_write_filter_module
 该模块是最后一个body模块

#子请求subrequest
 nginx发起一个子请求需要拥有自己得ngx_http_request_t结构，uri和args
 子请求需要重新从server rewrite阶段走一遍各个PHASE



#nginx内存相关
 nginx内存的操作主要在os/unix/ngx_alloc.{h,c}和core/ngx_palloc.{h,c}下

 ngx_alloc  使用malloc分配内存空间
 ngx_calloc 使用malloc分配，并将空间初始化为0
 ngx_memalign 返回一个指定的alignment大小的数值为对齐基数的空间
 ngx_free   释放内存

##创建内存池
 ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log);
 
 创建完后会初始化:
 pool->d.last = (u_char *)p + sizeof(ngx_pool_t);  //指向ngx_pool_t结构体的后面
 pool->d.end = (u_char *)p + size; //整个结构的结尾后面
 p->max = (size < NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL; //这个池的内存大小

##销毁内存池
  void ngx_destroy_pool(ngx_pool_t *pool);
 
  遍历链表释放所有内存,如果注册了cleanup链表,则调用该链表的handler

##重置内存池
  void ngx_reset_pool(ngx_pool_t * pool);
	
  释放所有large段内存，并将d->last指针重新指向ngx_pool_t结构之后，最后和创建时一样

##从内存池中分配内存
  void *ngx_palloc(ngx_pool_t *pool, size_t size);
  void *ngx_pnalloc(ngx_pool_t *pool, size_t size);
  void *ngx_pcalloc(ngx_pool_t *pool, size_t size);
  void *ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment);

  ngx_palloc分配内存过程如下:
  1.判断待分配的内存是否大于 pool->max, 如果大于则使用ngx_palloc_large在链表中分配,
    并将新的large指向旧的large,将新的返回。

  2.如果小于 pool->max 则尝试在pool->current链表中搜索出一个可以分别配的pool。  

  3.如果在pool->current 链表中无法找到足够大的限制内存,则调用ngx_palloc_block生成一个
    新的节点ngx_pool_t,并在新的节点里面分配内存并返回,同时将pool->current的指针指向
    新的位置,这个新位置从pool->d.failed 小于等于4的节点中找出。

##释放指定的内存
 ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p);

 只释放large链表的内存

##注册cleanup回调结构体(函数)
 
##创建一个数组容器
  ngx_array_t *ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size);
 
  n: 数组的个数
  size: 数组元素的大小

##销毁数组容器
  void ngx_array_destroy(ngx_array_t *a);

##插入数组
  void *ngx_array_push(ngx_array_t *a); //返回一个元素的指针
  void *ngx_array_push_h(ngx_array_t *a, ngx_uint_t n); //返回n个元素的指针

##ngx_queue nginx队列

##ngx_hash容器

##ngx_list容器


#Nginx模块命名规则
 ngx_服务名_模块名_module
 ngx_http_hello_module

#ngx_buf_t结构中几个重要的标志位
 last_buf:标示这是整个响应的最后一个缓冲区,nginx会立即发送缓冲区的所有数据
 last_in_chain:标示当前URI处理的最后一个缓冲区,用subrequest时用该标志位
 flush:标示要立即发送缓冲区的所有数据
 memory:标示缓冲区是内存缓冲
 in_file:标示缓冲区是文件缓冲

#自定义ctx变量
 每个模块在request中都已一个地方放置一个自定义的ctx变量,父子请求之间可以用这个
 作为通信的桥梁。
 用ngx_http_set_ctx(r,ctx,module)函数设置,该函数是一个宏
  #define ngx_http_set_ctx(r, c, module)      r->ctx[module.ctx_index] = c
 
 用ngx_http_get_module_ctx(r,module)获取,该函数也是一个宏
  #define ngx_http_get_module_ctx(r, module)  (r)->ctx[module.ctx_index]

#自定义结构体变量的获取
 我们自定义的main_conf、srv_conf、loc_conf结构体都放在了requst的相关字段中
 分别是 **main_conf、**srv_conf、**loc_conf。
 获取方式也是分别对应三个宏:
	#define ngx_http_get_module_main_conf(r, module)  (r)->main_conf[module.ctx_index]
	#define ngx_http_get_module_srv_conf(r, module)  (r)->srv_conf[module.ctx_index]
	#define ngx_http_get_module_loc_conf(r, module)  (r)->loc_conf[module.ctx_index] 
	
#编写filter模块
 filter模块和handler模块编写格式基本相同,不同的是注册方式。handler模块需要把自己的处理
 函数注册到相应的phase才能执行,并且相应的指令存在某个区域(http、server、location)才会被
 执行。filter模块只要被注册就会被执行,属于全局性质的,所以在filter处理函数内部需要写很多
 判断去尽量的不执行自己。

 注册filter一般放在所有指令都解析并合并完成阶段,也就是postconfiguration指向的函数中。
 首先该模块开始除会有两个全局变量:
	static ngx_http_output_header_filter_pt		ngx_http_next_header_filter;
	static ngx_http_output_body_filter_pt		ngx_http_next_body_filter; 

 这两个变量存放的是该过滤器执行完后下一个要执行的过滤器。

 向nginx注册filter,下面这个函数就是postconfiguration指向的函数:
	static ngx_int_t ngx_http_hello_filter(ngx_conf *cf){
		ngx_http_next_body_filter = ngx_http_top_body_filter;
		ngx_http_top_body_filter = ngx_http_footer_body_filter;

		ngx_http_next_header_filter = ngx_http_top_header_filter;
		ngx_http_top_header_filter = ngx_http_footer_header_filter;

		return NGX_OK;
	}

 nginx注册过滤器的顺序在编译完后的ngx_module_t *ngx_modules[]数组中.
 首先是注册初始化各个handler模块,然后才注册filter。
 
 注册顺序从上向下,当注册第一个过滤器时,过滤器链表头ngx_http_top_(header|body)_filter
 还没有值,所以第一个过滤器会把自己放入到链表头中:
	ngx_http_top_(header|body)_filter = ngx_http_(模块)_(header|body)_filter 
 这时候全局变量 top_(header|body)_filter 就有值了。

 接着注册第二个过滤器,在第二个过滤中,首先会把链表头的过滤器放入到本地变量中next_filter中
 然后把自己放入到链表头中。其中next_filter就是第二个过滤器执行完后要执行的filter。

 依次类推去注册剩下的过滤器,最后一个过滤器会成为链表头,所以过滤器是越往下越早执行。

#过滤器filter模块的config文件
 ngx_addon_name=ngx_http_(模块名)_filter_module
 HTTP_AUX_FILTER_MODULES="$HTTP_AUX_FILTER_MODULES ngx_http_(模块名)_filter_module" 
 NGX_ADDON_SRC="$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_(模块名)_filter_module.c"

 这个和handler模块注册不一样的就只用HTTP_AUX_FILTER_MODULES,handler是HTTP_MODULES 

#和ngx_http_core_module相关的结构体
 //核心模块自定义上下文 
 typedef struct {
	void		**main_conf;
	void		**srv_conf;
	void		**loc_conf;		
 } ngx_http_conf_ctx_t;

 //?为没一个其他模块生成一个,还是始终只有一份
 struct ngx_http_core_loc_conf_s {
	ngx_str_t		name;   //location name
	.......
    ngx_http_handler_pt	handler;  #//content handler	
	.......
 } 
 #define ngx_http_conf_get_module_loc_conf(cf, module)                         \
 		      ((ngx_http_conf_ctx_t *) cf->ctx)->loc_conf[module.ctx_index]

 typedef struct {
	ngx_array_t					server_names
	ngx_http_conf_ctx_t			*ctx;
	ngx_str_t					server_name;
	.......
	ngx_http_core_loc_conf_t	**named_locations;
 } ngx_http_core_srv_conf_t;
 #define ngx_http_conf_get_module_srv_conf(cf, module)                         \
 			   ((ngx_http_conf_ctx_t *) cf->ctx)->srv_conf[module.ctx_index]

 typedef struct {
	ngx_array_t			servers;	//ngx_http_core_srv_conf_t
	.........
	ngx_http_phase_t	phases[NGX_HTTP_LOG_PHASE + 1];   #//content phase handler;
 } ngx_http_core_main_conf_t;
 #define ngx_http_conf_get_module_main_conf(cf, module)                        \
    			((ngx_http_conf_ctx_t *) cf->ctx)->main_conf[module.ctx_index]


#--------------------nginx输出数据时的大致流程----------------------
 当nginx把所有请求头都解析完毕后,写事件handler变成了ngx_http_core_run_phases方法，
 该方法用来执行每个模块的所有的阶段handler,该方法快速执行完毕后,写事件handler就会被改写
 
  void
  ngx_http_core_run_phases(ngx_http_request_t *r)
  {
    ngx_int_t                   rc;  
    ngx_http_phase_handler_t   *ph; 
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    ph = cmcf->phase_engine.handlers;

    // checker = ngx_http_phase_handler_pt
    // 这里会循环执行所有的阶段,这里会快速的执行完毕,改变事件的操作在相关的阶段中完成
    // 当执行到ngx_http_core_content_phase时该方法先执行模块绑定的handler,
    
    // 每个模块的content_phase阶段绑定的handler都会去调用ngx_http_send_header输出响应头
    // 调用ngx_http_output_filter输出响应体,实际上响应头的信息也是有output_filter输出的
    // 执行完一次output_filter后，ngx_http_finalize_request方法将根据传入的rc决定是否
    // 调用ngx_http_set_write_handler方法将写事件handler改为r->write_event_handler=ngx_http_writer
    
    // 而ngx_http_writer又会去调用ngx_http_output_filter,当output_filter返回后会
    // 检查是否输出完毕，如果没有的话就直接返回,因为这时候写事件handler还是http_writer
    // 所以下一个写事件到来后会继续执行http_writer,如此反复执行,直到输出完毕后再次改写写事件handler
    while (ph[r->phase_handler].checker) {

        rc = ph[r->phase_handler].checker(r, &ph[r->phase_handler]);

        if (rc == NGX_OK) {
            return;
        }    
    }    
  }

  //ngx_http_core_content_phase的部分代码
  ngx_int_t
  ngx_http_core_content_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
  {
    size_t     root;
    ngx_int_t  rc;
    ngx_str_t  path;

	// 这种是按需绑定
    if (r->content_handler) {
        r->write_event_handler = ngx_http_request_empty_handler;
        ngx_http_finalize_request(r, r->content_handler(r));
        return NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                   "content phase: %ui", r->phase_handler);

    // 这种是按阶段绑定
    // 调用模块自己的handler,该handler中调用ngx_http_output_filter进行内容输出
    // 其中rc 就是ngx_http_output_filter的返回值
    rc = ph->handler(r);

    // 如果rc 不等于 NGX_DECLNED 就调用finalize_request去修改"写事件handler"
    if (rc != NGX_DECLINED) {

        ngx_http_finalize_request(r, rc);
        return NGX_OK;
    }

    ....... 
     
    return NGX_OK;
  }
#--------------------------ngxin输出数据的大致流程---------------------

#ngxin变量的创建和读取 
