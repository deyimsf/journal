Tcp首部数据格式
 0                                15  16                                31
 -------------------------------------------------------------------------
 |				16位源端口号         	|		16位目的端口号           |
 -------------------------------------------------------------------------
 |									32位序号							 |
 -------------------------------------------------------------------------
 |									32位确认序号				 		 |
 -------------------------------------------------------------------------
 |            |          |U|A|P|R|S|F|					 				 |
 |4位首部长度 | 保留(6位)|R|C|S|S|Y|I|		16位窗口大小		 		 |
 |	     	  |		 	 |G|K|H|T|N|N|					 				 |
 -------------------------------------------------------------------------
 |              16位校验和           |       16位紧急指针                |
 -------------------------------------------------------------------------
 |                               自定义选项                              |
 -------------------------------------------------------------------------
 |                                 数据                                  |
 -------------------------------------------------------------------------

Tcp首部中6个标志比特说明
 URG	紧急指针(urgent pointer)
 ACK	确认应答
 PSH	接收方应该尽快将这个报文段交给应用层
 RST	重建连接
 SYN	请求建立连接
 FIN	请求断开连接

MSS:最大报文段长度，表示TCP传往另一端的最大块数据的长度。
 对于以太网，MSS值最大可到1500 - IP首部(20) - TCP首部(20) = 1460字节
 对于802.3，MSS之最大可到1492 - IP首部(20) - TCP首部(20) = 1452字节

Tcp建立连接  mss:Maximum Segement Size  MTU:Maxmum Transmission Unit(链路层叫法)
                            SYN 157445:157445 <mss 1024>
  SYN_SENT     |--------------------------------------------------->|   SYN_RCVD
               |       SYN 189893:189893 ack 157446 , <mss 1024>    |
 ESTABLISHD    |<---------------------------------------------------|
               |                   ack 189894                       |
               |--------------------------------------------------->|  ESTABLISHED

Tcp终止连接
                           |         FIN          |
 主动关闭   FIN_WAIT_1     |--------------------->|     CLOSE_WAIT 被动关闭
		       			   |	     ACK          |
 	  		FIN_WAIT_2     |<---------------------|          
           				   |	     FIN          |
	  		TIME_WAIT      |<---------------------|      LAST_ACK
           		   		   |	     ACK          |
			   			   |--------------------->|      CLOSED
                           |                      |
			NOTE:对于被动关闭的一端是否发送FIN(CLOSE_WAIT-->LAST_ACK),取决于应用
				 程序是否调用close()方法，如果不调用则被动关闭端保持CLOSE_WAIT,
				 对端保持FIN_WAIT2状态。区别在于主动关闭一端的应用程序已经关闭，
				 剩下的工作已经全权委托操作系统，而被动关闭端的应用程序没有关闭
				 该链接(socket),或者应用程序异常终止了,没有再向对端发送任何数据.
			所以根据以上结论，当系统出现大量CLOSE_WAIT时,肯定是应用程序没有调用
			close()方法。

套接字复位(RST,异常关闭)
 RST报文段不会导致另一端产生任何响应，另一端根本不进行确认。
 收到RST的一方将终止该连接，并通知应用层连接复位。
 java例子:
  ServerSocket ss = new ServerSocket(8989);
  whil(true){
	Socket s = ss.accept();
	s.setSoLinger(true,0);
	s.close();
 } 

半打开连接
 如果一方已经关闭或异常终止连接而另一方还不知道，这种TCP连接称为半打开(Half-Open)
 只要不打算在半打开连接上传输数据，仍处于连接状态的一方就不会检测另一方已经出现异常。

半关闭
  TCP连接的一端在结束它的发送后还能接收来自另一端数据的能力。很少应用程序使用。

SO_REUSEADDR
  该选项可以决定，处在TIME_WAIT状态的连接是否可以被新的连接使用
SO_LINGER
  设置TCP关闭连接时的行为,默认当close()Tcp连接后,系统会将write buffer中的数据
  发送给对端,然后发FIN报文并等待对方确认来完成四次挥手(FIN ACK FIN ACK)。
 
  如果我们将该值设为0,则直接通过发送RST报文来关闭连接,此时buffer中的数据也会直接
  丢弃。这种方式对于主动关闭端来说会跳过TIMEWAIT状态。

  如果为非零则代表一个超时,如果在close()后在指定的时间内能够收到对方的确认,则进入
  正常的四次挥手阶段,否则直接发送RST报文。

TCP_NODELAY
 *可以用来关闭Nagle算法；
 *Nagle算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，
  在该分组的确认未到达之前不能发送其他的小分组。同时在等待确认应答
  道来时，Tcp会收集这些小分组，然后打包发送。
  例子：
	telnet www.jd.com 80
  连接上之后我们发这样的数据:
	a
	a
	a
	
  在telnet中敲完回车后，会立即向对端发数据。根据上面的输入可以知道，
  我们发了三次数据，理论上应该产生三个tcp包，实际上只产生了两个。
  原因是第一个包太小，所以在没有收到ack之前不会再发数据，一旦收到ack，
  如果在发第一个包和ack之间又输入了多个小于一个报文段的数据，那么Nagle
  算法是不会发数据的。他会收集这些小分组数据，等收到之前的小分组的ack后
  ，或者收集的数据已经累计到一个报文段的大小，再发数据。	


 *如果服务端从不向客户端发送数据，那么就会经常触发服务器的经受时延的
  确认算法，会有一个200ms内的确认延迟。
SO_RCVBUF
 设置窗口大小
SO_KEEPALIVE
 是否开启保活设置，默认两小时没有数据流通则发送ACK探查包。

TCP滴答计时器(比如200ms一个滴答)   
  TCP软件启动，每隔200ms一个滴答，如下图
    0___1___2___3___4___5___6___7___8___9___10___11___12...504...
  
   设置一个1秒的定时器，需要为该定时器的计数器设为5个滴答
     如果刚好在2这个滴答时候之后设置定时器成功，那么该定时器经历3、4、5、6、7这5个
   滴答之后计数器恢复为零。该定时器历经1秒。
     如果在2~3这两个滴答中间设置计数器，那么该定时器同样经历3、4、5、6、7这5个滴答。
   此时定时器经历900ms。
   
TCP往返时间(RTT)的测定
   在一个连接中，每次发送数据都会先检查定时器是否被使用，如果没有则定时器启动并开始计时，
 待这次发送的数据返回ack后，定时器关闭并记录经历的滴答个数。
    

Tcp慢启动和避免拥塞算法
  该算法可以看"慢启动和避免拥塞算法.jpg/.docx"
  常规避免拥塞算法在发送超时拥塞时，会设置成慢启动(cwnd=1)。
  快速重传：在收到3个及以上的重复ACK后，重传报文不等待定时器溢出。
  快速恢复：快速重传之后不执行慢启动算法，而是执行避免拥塞算法。

滑动窗口
 *窗口左边沿向右边沿靠近称为窗口合拢。发生在数据被发送和确认时。
 *窗口右边沿向右边移动时将允许发送更多的数据，叫窗口张开。发生在另一端接收进程读取
  已确认的数据并释放了TCP缓存时。
 *右边向左边移动时，叫窗口收缩。Host Requirements RFC不建议使用这种方式。

#超时重传机制
  当发送方发现，在timeout时间内收不到已发送包3的ack后，会重传该包3。
  多数实现会直接重传3及其在改时间内已经发出去的4、5等包。

#快速重传机制
  不再以timeout为界限，而以ack个数驱动重传。如果发送方连续3次收到相同的ack,
 就重传。

#Tcp的KeepAlive,有三个选项可设置
 $sysctl -a | grep tcp_keepalive
  
 net.ipv4.tcp_keepalive_time = 7200
   TCP链路在经过多少秒后没有数据报文传输就启动保活探测
 net.ipv4.tcp_keepalive_probes = 9
   当前最多探测的次数 
 net.ipv4.tcp_keepalive_intvl = 75 
   当前发送每个探测报的间隔秒数

 如果系统支持的话可以为每个socket设置这些参数,使用setsockopt设置
 TCP_KEEPIDLE 对应 keepalive_time
 TCP_KEEPCNT 对应 keepalive_probes
 TCP_KEEPINTVL 对应 keepalive_intvl 

 例子:
  Nginx中得listen指令有一个参数可以设置TCP层的keepalive
  so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt] 
  三个参数,on是开启,off关闭,最后是直接指定keepalive时间	
 
  listen 8080 so_keepalive=7200:75:9

