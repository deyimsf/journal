#hello world
 print("Hello World");

#命令行方式执行lua: lua[options] [script [args]]
 -e:直接将命令传入lua并执行
  $ lua -e "print('hello world')" --> hello world
 
 -l:加载一个文件并执行(默认)
    ----------->test.lua<-----------
		print("hello world");
  	-------------------------------- 
  $ lua -l test.lua

 -i:进入交互模式
 
 _PROMPT:该变量可更改交互模式的提示符,例如
 $ lua -i -e "_PROMPT='lua>'"
 lua>

#全局变量arg用于存放Lua的命令行参数
 lua用所有参数构造arg表,脚本名索引为0，脚本后从1开始，脚本后从-1开始
 	------------>test.lua<-----------
		print("arg[-1]="..arg[-1]);
		print("arg[0]="..arg[0]);
		print("arg[1]="..arg[1]);
	---------------------------------
 $ lua -e "c=c" test.lua a b
   arg[-1]=c
   arg[0]=test.lua
   arg[1]=a

#获取数据类型
 print(type("hello world"));		-->string
 print(type(20*3));					-->number
 print(type(print));				-->function
 print(type(true));					-->boolean 
 print(type(a));					-->nil

#可以用[[]]表示字符串，里面的内容不用转义
 lua> page=[[<html> </htm> "a"]] 
 
 lua> io.write(page);

#逻辑运算符 and or not
 false和nil是假，其它为真
 a and b	--如果a为false，则返回a,否则返回b
 a or b		--a为true返回a，否则返回b

#表的构造
 days={"sunday","monday","tuesday"}
 等价于
 days={[1]="sunday",[2]="monday",[3]="tuesday"}

#赋值
 a,b,c = 0,1;
 print(a,b,c);   -->0,1,nil

#控制语句
 if xxx then ... end
 if xxx then ... else ... end
 if xxx then ... elseif xxx then ... else ... end

 while xxx do 
   ...
 end

 repeat
	...
 until xxx

#for语句
 for var=exp1(初始值),exp2(终止值),exp3(step) do
	...
 end

 for i,v in ipairs(array) do
	...
 end
 //i是数组的第几个，v是数组值

 for k,v in pairs(table) do
	...
 end
 //k是表的key，v是表的值

#可变参数
 function select(...)
	local a,b,c = ...;
	print({...}); //传过来的参数放在表中
    for i,v in ipairs({...}) do
		print(i.."--"..v);
	end
 end

#函数排序
	net={"a","b","c"};
  	print(net[1].."--"..net[2].."--"..net[3]);  -->a b c
  	
  	table.sort(net,
  	           function(a,b)
  	               return (a>b);
  	           end
  	)
  	print(net[1].."--"..net[2].."--"..net[3])   -->c b a
 
#当一个函数内部嵌套另一个函数定义时,内部的函数体可以访问外部函数的局部变量
 ,这种特征我们称作词法定界(闭包)。

#闭包
	function nc()
		local i = 0;
		return function()
				 i=i+1;
				 return i;
			   end
	end   

	nc();		 -->function: 0x7fd9024066a0(匿名函数的地址) 
	c1 = nc();   --将返回的匿名函数赋值给c1
    print(c1()); -->1
    print(c2()); -->2
    
#利用闭包重写open函数
	do
		local old_open = io.open
		io.open=function(filename,mode)
					if access_ok(filename,mode) then
						return old_open(filename,mode);
					else
						return nil,"access denied";
					end
				end
	end

#闭包是一个内部函数，它可以访问一个或者多个外部函数的外部局部变量。
 每次闭包的成功调用后，这些外部局部变量(upvalue)都保存他们的值。

#创建闭包的代价比创建table小；处理闭包要比处理table速度快.

#dofile加载一个文件并执行

#loadfile加载一个文件，将其编译成中间代码并返回编译后的chunk作为一个函数，不执行代码。
 lua中的函数定义发生在运行时的赋值而不是发生在编译时。
	 --------------------->foo.lua<------------------------
		function aa()
			print("aa");
		end
	
		function bb()
			print("bb");
		end
 	------------------------------------------------------
 lua> f,v = loadfile("foo.lua");  --只是加载foo.lua文件
	 //如果加载错误，f=nill、v=错误信息
 lua> f();	--定义aa bb,之后aa、bb就可以使用了
 lua> aa();	-->aa
 lua> bb(0; -->bb

 和loadstring一样都不会抛出错误，如果发生错误他们将返回nil和编译错误信息
 如:
	print(loadstring("i i"))	-->[string "i i"]:1: syntax error near 'i'
 
#loadstring与loadfile类似，只不过它从一个串中读入chunk
 lua> f = loadstring("i=i+1");
 //f是一个函数，只有调用时才执行;
 lua> i = 0;
 lua> f(); print(i);  -->1

#lua把每一个chunk都作为一个匿名函数处理。
 例如：
	chunk "a=1";
	loadstring("a=1");
 返回与其等价的函数:
    function () 
		a=1
	end

#require函数，和dofile类似，编译并执行程序
 1.require会搜索目录加载文件
 2.require会判断是否文件已经加载避免重复加载同一文件。
 例如：
 lua> require("test");  --加载并运行test.lua中得内容
 lua> aa();		-->aa

#assert函数
 //如果aa()执行失败，返回后面的信息，否则正常返回(print()有点问题)
 n=assert(aa(),"aa()执行时错误 ");
 
#pcall函数和error函数可以配合在lua中处理异常和错误
 使用pcall执行代码，如果代码返回错误，则pcall返回false和nil;否则返回true
 例子：
	function foo(v)
		status,err=pcall(function()      //相当于java中得try catch
						   if v==1 then
							 //数字是错误级别。
						     error("errors",2); //相当于java中得throw exception
						   else
							 return "hello";
						   end
						 end
					)

		print(status);
		print(err)
   end

#输出栈信息
lua> print(debug.traceback())


#创建协同
 co = coroutine.create(
	  	function()
			print("hi");
		end
	  )
 print(co) -->thread:0x80237690
 print(type(cp)) -->thread

#协同状态
 挂起(suspended)、运行、停止(dead)

#查看协同状态
 print(coroutine.status(co)) -->suspended

#运行挂起状态的程序
 coroutine.resume(co)	-->hi
 print(coroutine.status(co))  -->dead  //运行后状态变为停止

#将运行的程序挂起yield
 co = coroutine.create(
	  	function()
			for i=1,5 do
				print("aa");
				//运行到这里就会挂起,当程序激活的时候会继续执行
				coroutine.yield();
			end 
		end
	  ) 
  //运行
  coroutine.resume(co);			-->aa
  print(coroutine.status(co))	-->suspended

#将一个表链接成字符串
 t={"a","b","c"}
 s=table.concat(t)	-->abc
 s=table.concat(t,"-") -->a-b-c 

#metatables可以改变table的行为 
 lua对两个表相加时会检查两个表是否其中一个有metatable,
 并检查__add域，如果有则用该函数去计算结果。

#获取表的metatable
 lua>t={}
 lua>print(getmetatable(t))    -->nil //默认没有元表

 lua>t1={}
 lua>setmetatable(t,t1)
 lua>assert(getmetatable(t) == t1)

#任何表可以是其他表的metatable，可以共享metatable,也可以是自身.

#metamethod方法
 __add、__sub __mul __div __unm(负) __pow(幂) __concat __eq __lt __le
 __tostring 
 例子：
   m = {}  //元表
   m.__add = function()...end  //定义表+操作
   
   a = {}; setmetatable(a,m); //设置元表
   b = {}; setmetatable(b,m); //设置元表
 此后a+b就是用m.__add函数来处理的

 lua选择metamethod的原则是按顺序找，最后没找到则报错
  
#metafile _metatable,这个属性是设置在元表上的
 如果对metatable设置了__metatable值,getmetatable将返回赋给这个的值，
 调用setmetatable会出错
 例如:
	m={};
	t={};
	
	setmetatable(t,m);
	print(getmetatable(t));		-->table:0x808384

	m.__metatable="haha";
	print(getmetatable(t));		-->haha
	setmetatable(t,{});			-->报错	
  
#__index
 当访问表中的一个不存在的域的时候，lua解释器去查找metatable中__index是否存在，
 如果不存在返回nil；否则，则按__index指定的方法返回结果
 例如:
	m={};
	t={"a"};
	setmetatable(t,m);
	m.__index=function (table,key) return "bb" end  //table是当前table,key是调用的域

	print(t.a);		-->a
	print(t.b);		-->bb

#__index不需要非是一个函数，也可以是一个表。当是一个表的时候,将在这个表中查看是否
 有缺少的域。
 例如：
	m.__index={"bb"};

#__newindex用来对表更新；当给表的一个不存在的域赋值时，就会调用这个函数

#rawget(table,key)和rawset(table,key,value)
 这两个函数可以绕过__index和__newindex等metamethod方法

#lua的所有全局变量都存在_G表中
 for n in pairs(_G) do
	print(n)
 end

#改变一个函数的环境setfenv
 a=1;
 setfenv(1,{}); //改变当前函数的环境变量
 print(a);  -->报错，因为当前函数的环境变量变为空,里面没有print函数

#weak 虚表
 表的weak性有他的元表(metatable)的__mode域来指定，__mode的值是字符串
 例如：
	m={};
	t={};
	setmetatable(t,m);
	m.__mode="k";   //t表的keys时weak的，可以被垃圾收集掉
    m.__mode="v";	//valus是weak的
    m.__mode="kv";	//keys、values都是weak的
  注意：只有对象(表|函数)才可以从一个weak table中被收集。字符、数字等都不会
  所以如果想key被收集应该这样:
	key={};     //key
	t={};		
	t[key] = 1; //赋值,这样这个key就是可以被收集掉的

#(#)返回一个表的最后索引
例如：
	t={12,432,32}
	print(#t);		-->3

#插入删除元素
 t={10,28};
 table.insert(t,20);  //插入一个元素t={10,28,20}
 table.insert(t,1,25);//指定位置插入一个元素t={15,10,28,20} 

 table.remove(t,1);   //删除第一个元素 t={10,28,20}

#ipairs、pairs遍历数组.前者使用key的顺序1、2...，后者用表的自然存储顺序

#字符串函数	
 string.len("abc");   //返回字符串的长度,3
 string.rep("abc",2); //将字符串重复两次返回,abcabc
 string.lower("ABC"); //大写转小写 abc
 string.upper("abc");
 string.sub("abc",1,2); //截取字符串
 string.format("%d=%d",4,5);//格式和C语言的print一样

#查找字符串string.find(str,substr,index)  index是开始搜索位置
 i,j=stringfind("hello world","hello"); 
 print(i,j); -->1,5 //查找成功,返回子串的开始和结束索引;否则返回nil

#全局字符串替换 string.gsub(str,arg1,arg2,scope) scope是要替换的个数
 s=string.gsub("Lua is cute","cute","great");
 print(s);	-->Lua is great

 s=string.gsub("aa aa aa","a","b",2);
 print(s);	-->bb aa aa
 
#全局字符串查找string.gfind


#模式
 .		任意字符
 %a		字母
 %c		控制字符
 %d		数字
 %l		小写字母
 %p		标点字符
 %s		空白符
 %u		大写字母
 %w		字母和数字
 %x		十六进制数字
 %z		代表0的字符

#捕获子串
 date="17/7/1990";
 i,j,d,m,y=string.find(date,"(%d+)/(%d+)/(%d+)");
 print(i,j,d,m,y);	-->1 9	17	7  1990

#对子串的引用
 s="\command{some text}";
 s=string.gsub(s,"\\(%a+){(.-)}","<%1>%2</%1>");
 print(s);		--><command>some text</command>


#I/O库的所有函数都放在表io中
 print(io);  -->table:0x9d9a0a8a

#简单I/O操作在标准输入(stdin)和标准输出(stdout)
 例如：
	s=io.read(); //之后要求从键盘输入数据，比如abc
	print(s);	-->
	
	io.write("abc\n"); //向屏幕输出abc
 可以用io.input和io.output改变当前文件
 例如：
	------------------>foo.lua<-----------------------
		hello
		nihao
		haha
	--------------------------------------------------
 	io.input("foo.lua"); //之后所有输入都来自该文件	
	s=io.read();
	print(s);	-->hello
	s=io.read();	
	print(s);	-->nihao
	
	//读取整个文件
	io.input("foo.lua");
	s=io.read("*all");
	print(s);	-->hello
				   nihao
				   haha
    //读取下一行
	io.input("foo.lua");
	s=io.read("*line"); 
	print(s);	-->hello
	
	//从一行中转换出一个数值，如果这行有数字的话
    s=io.read("*number");
	
	//读取num个字符
	s=io.read("*8");
    
#完全模式I/O，可以持有一个文件句柄，类似C语言中的FILE*
 filename:文件名
 model:打开类型;r(读) w(写) a(附加) b(二进制)
 return:正确打开，返回文件句柄(file (0x7fff7687d598))
		错误打开，返回nil	错误信息
 io.open(filename,model); 
 例如：
	f = io.open("/etc/passwd","r");
	print(f);	-->file (0x7fff7687d598)

#对完全I/O模式的读写要用冒号
 //读整个文件
 f = io.open("foo.lua");
 t = t:read("*all");
 f:close();	//关闭文件  

#发送错误信息到标准错误输出
 io.stderr:write(message);

#读取一个文件的一段并加上一行，这样可以避免切割文件中的行
 text,rest = f:read(30,"*line");  //读取30个字符加一行

#获取某个日期的时钟值
 print(os.time({year=1970,month=1,day=1})); -->12600

#创建一个时间表
 date = os.date("*t",12600);
 //date是一个时间表{year=1970,month=1,day=1,...}

#格式化时间
 date = os.date(model,[时钟值]);
 print(os.date("%Y%m%d")); -->20140820

#获取系统环境变量
 print(os.getenv("HOME"));  -->/home/lua

#执行系统命令
 os.execute("mkdir c");  //创建一个目录c

#debug库,获取函数的一些信息
 s = debug.getinfo(函数);
 print(s.source);   //表明函数被定义的地方
 print(s.short_src); //source的简短版本
 print(s.linedefined);//函数被定义之处的行号
 print(s.what);// 表明是C函数、Lua函数、Lua的主chunk
 s.name
 s.namewhat
 s.nups  //函数的upvalues(外部局部变量)的个数
 s.func  //函数本身

#以数字的方式调用debug.getinfo(n)
 返回在n级栈的活动函数的信息数据。
 n=0 ,表示C函数getinfo本身
 n=1 ,表示正在调用的函数的信息

#Hooks,注册一个函数，用来在程序运行中某一事件到达时被调用。
 debug.sethook(foo,"call"):当Lua调用一个函数的时候，调用foo函数
 debug.sethook(foo,"return"):当一个函数返回的时候调用foo函数
 debug.sethook(foo,"line"): 当lua开始执行代码的新行的时候
 debug.sethook(foo,"count",2):执行两个指令后执行foo函数//?不确定这么用
 
#关掉hooks
 debug.sethook();






